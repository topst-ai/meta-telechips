From 5f15175c443bb93cf46974ea5ae58e7abc7471e4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=EC=9E=84=EC=98=81=ED=98=84=28Lim=20Young=20Hyun=29?=
 <limdh3@telechips.com>
Date: Mon, 13 Sep 2021 12:22:54 +0900
Subject: [PATCH] 0002-Modify-TC-AM-Daemon-TCC805x

---
 AudioManagerDaemon/include/CAmRoutingReceiver.h |    2 +-
 AudioManagerDaemon/src/CAmRoutingReceiver.cpp   |    3 +-
 include/IAmCommand.h                            |  748 ++++----
 include/IAmControl.h                            | 2070 +++++++++++------------
 include/IAmRouting.h                            |  978 +++++------
 5 files changed, 1901 insertions(+), 1900 deletions(-)

diff --git a/AudioManagerDaemon/include/CAmRoutingReceiver.h b/AudioManagerDaemon/include/CAmRoutingReceiver.h
index bb518da..4f9dbb1 100644
--- a/AudioManagerDaemon/include/CAmRoutingReceiver.h
+++ b/AudioManagerDaemon/include/CAmRoutingReceiver.h
@@ -79,7 +79,7 @@ public:
     void hookSourceAvailablityStatusChange(const am_sourceID_t sourceID, const am_Availability_s& availability);
     void hookDomainStateChange(const am_domainID_t domainID, const am_DomainState_e domainState);
     void hookTimingInformationChanged(const am_connectionID_t connectionID, const am_timeSync_t delay);
-	void hookPulseConnectionRequest(const am_sourceID_t sourceID, const am_sinkID_t sinkID, am_mainConnectionID_t & mainConnectionID);
+	void hookPulseConnectionRequest(const am_sourceID_t sourceID, const am_sinkID_t sinkID, am_mainConnectionID_t & mainConnectionID, const am_volume_t volume);
 	void hookPulseDisconnectionRequest(const am_mainConnectionID_t mainConnectionID);
     void sendChangedData(const std::vector<am_EarlyData_s>& earlyData);
     am_Error_e getDBusConnectionWrapper(CAmDbusWrapper*& dbusConnectionWrapper) const;
diff --git a/AudioManagerDaemon/src/CAmRoutingReceiver.cpp b/AudioManagerDaemon/src/CAmRoutingReceiver.cpp
index 85404df..82c794b 100644
--- a/AudioManagerDaemon/src/CAmRoutingReceiver.cpp
+++ b/AudioManagerDaemon/src/CAmRoutingReceiver.cpp
@@ -326,9 +326,10 @@ void CAmRoutingReceiver::hookTimingInformationChanged(const am_connectionID_t co
     mpControlSender->hookSystemSingleTimingInformationChanged(connectionID,delay);
 }
 
-void CAmRoutingReceiver::hookPulseConnectionRequest(const am_sourceID_t sourceID, const am_sinkID_t sinkID, am_mainConnectionID_t & mainConnectionID)
+void CAmRoutingReceiver::hookPulseConnectionRequest(const am_sourceID_t sourceID, const am_sinkID_t sinkID, am_mainConnectionID_t & mainConnectionID, const am_volume_t volume)
 {
 	mpControlSender->hookUserConnectionRequest(sourceID, sinkID, mainConnectionID);
+	mpControlSender->hookUserSourceVolumeChange(sourceID, volume);
 }
 
 void CAmRoutingReceiver::hookPulseDisconnectionRequest(const am_mainConnectionID_t mainConnectionID)
diff --git a/include/IAmCommand.h b/include/IAmCommand.h
index fdcfea8..86d0291 100644
--- a/include/IAmCommand.h
+++ b/include/IAmCommand.h
@@ -1,393 +1,393 @@
-/**
- * Copyright (C) 2012 - 2014, BMW AG
- *
- * This file is part of GENIVI Project AudioManager.
- *
- * Contributions are licensed to the GENIVI Alliance under one or more
- * Contribution License Agreements.
- *
- * \copyright
- * This Source Code Form is subject to the terms of the
- * Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
- * this file, You can obtain one at http://mozilla.org/MPL/2.0/.
- *
- *
- * \author Christian Linke, christian.linke@bmw.de BMW 2011 - 2014
- *
- * \file
- * For further information see http://projects.genivi.org/audio-manager
- *
- * THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. 
- * PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN.
- */
-#if !defined(EA_D9D48C0D_77EC_4fa7_B861_1827740C7ECA__INCLUDED_)
-#define EA_D9D48C0D_77EC_4fa7_B861_1827740C7ECA__INCLUDED_
-
-#include <vector>
-#include <string>
-#include "audiomanagertypes.h"
-namespace am {
-class CAmDbusWrapper;
-class CAmSocketHandler;
-}
-
-
-#include "audiomanagertypes.h"
-
-#define CommandVersion "3.0" 
-namespace am {
-
-/**
- * The interface towards the Controlling Instance (e.g HMI). It handles the
- * communication towards the HMI and other system components who need to interact
- * with the audiomanagement.
- * There are two rules that have to be kept in mind when implementing against this
- * interface:\n
- * \warning
- * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
- * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
- * CALL THAT EXPECTS A RETURN VALUE.\n
- * \details
- * Violation these rules may lead to unexpected behavior! Nevertheless you can
- * implement thread safe by using the deferred-call pattern described on the wiki
- * which also helps to implement calls that are forbidden.\n
- * For more information, please check CAmSerializer
- */
-class IAmCommandReceive
-{
-
-public:
-	IAmCommandReceive() {
-
-	}
-
-	virtual ~IAmCommandReceive() {
-
-	}
-
-	/**
-	 * This function returns the version of the interface.
-	 */
-	virtual void getInterfaceVersion(std::string& version) const =0;
-	/**
-	 * connects a source to sink
-	 * @return E_OK on success, E_NOT_POSSIBLE on failure, E_ALREADY_EXISTS if the
-	 * connection does already exists
-	 */
-	virtual am_Error_e connect(const am_sourceID_t sourceID, const am_sinkID_t sinkID, am_mainConnectionID_t& mainConnectionID) =0;
-	/**
-	 * disconnects a mainConnection
-	 * @return E_OK on successes, E_NON_EXISTENT if the connection does not exist,
-	 * E_NOT_POSSIBLE on error.
-	 */
-	virtual am_Error_e disconnect(const am_mainConnectionID_t mainConnectionID) =0;
-	/**
-	 * sets the volume for a sink
-	 * @return E_OK on success, E_UNKOWN on error, E_OUT_OF_RANGE in case the value is
-	 * out of range
-	 */
-	virtual am_Error_e setVolume(const am_sinkID_t sinkID, const am_mainVolume_t volume) =0;
-	/**
-	 * This function is used to increment or decrement the current volume for a sink.
-	 * @return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the value is
-	 * not in the given volume range.
-	 */
+/**
+ * Copyright (C) 2012 - 2014, BMW AG
+ *
+ * This file is part of GENIVI Project AudioManager.
+ *
+ * Contributions are licensed to the GENIVI Alliance under one or more
+ * Contribution License Agreements.
+ *
+ * \copyright
+ * This Source Code Form is subject to the terms of the
+ * Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
+ * this file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ *
+ * \author Christian Linke, christian.linke@bmw.de BMW 2011 - 2014
+ *
+ * \file
+ * For further information see http://projects.genivi.org/audio-manager
+ *
+ * THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. 
+ * PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN.
+ */
+#if !defined(EA_D9D48C0D_77EC_4fa7_B861_1827740C7ECA__INCLUDED_)
+#define EA_D9D48C0D_77EC_4fa7_B861_1827740C7ECA__INCLUDED_
+
+#include <vector>
+#include <string>
+#include "audiomanagertypes.h"
+namespace am {
+class CAmDbusWrapper;
+class CAmSocketHandler;
+}
+
+
+#include "audiomanagertypes.h"
+
+#define CommandVersion "3.0" 
+namespace am {
+
+/**
+ * The interface towards the Controlling Instance (e.g HMI). It handles the
+ * communication towards the HMI and other system components who need to interact
+ * with the audiomanagement.
+ * There are two rules that have to be kept in mind when implementing against this
+ * interface:\n
+ * \warning
+ * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
+ * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
+ * CALL THAT EXPECTS A RETURN VALUE.\n
+ * \details
+ * Violation these rules may lead to unexpected behavior! Nevertheless you can
+ * implement thread safe by using the deferred-call pattern described on the wiki
+ * which also helps to implement calls that are forbidden.\n
+ * For more information, please check CAmSerializer
+ */
+class IAmCommandReceive
+{
+
+public:
+	IAmCommandReceive() {
+
+	}
+
+	virtual ~IAmCommandReceive() {
+
+	}
+
+	/**
+	 * This function returns the version of the interface.
+	 */
+	virtual void getInterfaceVersion(std::string& version) const =0;
+	/**
+	 * connects a source to sink
+	 * @return E_OK on success, E_NOT_POSSIBLE on failure, E_ALREADY_EXISTS if the
+	 * connection does already exists
+	 */
+	virtual am_Error_e connect(const am_sourceID_t sourceID, const am_sinkID_t sinkID, am_mainConnectionID_t& mainConnectionID) =0;
+	/**
+	 * disconnects a mainConnection
+	 * @return E_OK on successes, E_NON_EXISTENT if the connection does not exist,
+	 * E_NOT_POSSIBLE on error.
+	 */
+	virtual am_Error_e disconnect(const am_mainConnectionID_t mainConnectionID) =0;
+	/**
+	 * sets the volume for a sink
+	 * @return E_OK on success, E_UNKOWN on error, E_OUT_OF_RANGE in case the value is
+	 * out of range
+	 */
+	virtual am_Error_e setVolume(const am_sinkID_t sinkID, const am_mainVolume_t volume) =0;
+	/**
+	 * This function is used to increment or decrement the current volume for a sink.
+	 * @return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the value is
+	 * not in the given volume range.
+	 */
 	virtual am_Error_e setSourceVolume(const am_sourceID_t sourceID, const am_mainVolume_t volume) =0;
 	/**
 	 * This function is used to increment or decrement the current volume for a source.
 	 * @return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the value is
 	 * not in the given volume range.
 	 */
-	virtual am_Error_e volumeStep(const am_sinkID_t sinkID, const int16_t volumeStep) =0;
-	/**
-	 * sets the mute state of a sink
-	 * @return E_OK on success, E_UNKNOWN on error. If the mute state is already the
-	 * desired one, the Daemon will return E_OK.
-	 */
-	virtual am_Error_e setSinkMuteState(const am_sinkID_t sinkID, const am_MuteState_e muteState) =0;
-	/**
-	 * This method is used to set sound properties, e.g. Equalizer Values. Since the
-	 * capabilities of the system can differ, the exact key value pairs can be
-	 * extended in each product
-	 * @return E_OK on success, E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in
-	 * case of an error
-	 */
-	virtual am_Error_e setMainSinkSoundProperty(const am_MainSoundProperty_s& soundProperty, const am_sinkID_t sinkID) =0;
-	/**
-	 * This method is used to set sound properties, e.g. Equalizer Values. Since the
-	 * capabilities of the system can differ, the exact key value pairs can be
-	 * extended in each product
-	 * @return E_OK on success, E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in
-	 * case of an error
-	 */
-	virtual am_Error_e setMainSourceSoundProperty(const am_MainSoundProperty_s& soundProperty, const am_sourceID_t sourceID) =0;
-	/**
-	 * is used to set a specific system property.
-	 * @return E_OK on success, E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in
-	 * case of an error
-	 */
-	virtual am_Error_e setSystemProperty(const am_SystemProperty_s& property) =0;
-	/**
-	 * returns the actual list of MainConnections
-	 * @return E_OK on success, E_DATABASE_ERROR on error 
-	 */
+	virtual am_Error_e volumeStep(const am_sinkID_t sinkID, const int16_t volumeStep) =0;
+	/**
+	 * sets the mute state of a sink
+	 * @return E_OK on success, E_UNKNOWN on error. If the mute state is already the
+	 * desired one, the Daemon will return E_OK.
+	 */
+	virtual am_Error_e setSinkMuteState(const am_sinkID_t sinkID, const am_MuteState_e muteState) =0;
+	/**
+	 * This method is used to set sound properties, e.g. Equalizer Values. Since the
+	 * capabilities of the system can differ, the exact key value pairs can be
+	 * extended in each product
+	 * @return E_OK on success, E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in
+	 * case of an error
+	 */
+	virtual am_Error_e setMainSinkSoundProperty(const am_MainSoundProperty_s& soundProperty, const am_sinkID_t sinkID) =0;
+	/**
+	 * This method is used to set sound properties, e.g. Equalizer Values. Since the
+	 * capabilities of the system can differ, the exact key value pairs can be
+	 * extended in each product
+	 * @return E_OK on success, E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in
+	 * case of an error
+	 */
+	virtual am_Error_e setMainSourceSoundProperty(const am_MainSoundProperty_s& soundProperty, const am_sourceID_t sourceID) =0;
+	/**
+	 * is used to set a specific system property.
+	 * @return E_OK on success, E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in
+	 * case of an error
+	 */
+	virtual am_Error_e setSystemProperty(const am_SystemProperty_s& property) =0;
+	/**
+	 * returns the actual list of MainConnections
+	 * @return E_OK on success, E_DATABASE_ERROR on error 
+	 */
 	virtual am_Error_e getVolume(const am_sinkID_t sinkID, am_mainVolume_t& mainVolume) const =0;
 
 	virtual am_Error_e getSourceVolume(const am_sourceID_t sourceID, am_mainVolume_t& mainVolume) const =0;
 
-	virtual am_Error_e getListMainConnections(std::vector<am_MainConnectionType_s>& listConnections) const =0;
-	/**
-	 * returns the actual list of Sinks
-	 * @return E_OK on success, E_DATABASE_ERROR on error 
-	 */
-	virtual am_Error_e getListMainSinks(std::vector<am_SinkType_s>& listMainSinks) const =0;
-	/**
-	 * returns the actual list of Sources
-	 * @return E_OK on success, E_DATABASE_ERROR on error 
-	 */
-	virtual am_Error_e getListMainSources(std::vector<am_SourceType_s>& listMainSources) const =0;
-	/**
-	 * This is used to retrieve all source sound properties related to a source.
-	 * Returns a vector of the sound properties and values as pair
-	 * @return E_OK on success, E_DATABASE_ERROR on error 
-	 */
-	virtual am_Error_e getListMainSinkSoundProperties(const am_sinkID_t sinkID, std::vector<am_MainSoundProperty_s>& listSoundProperties) const =0;
-	/**
-	 * This is used to retrieve all source sound properties related to a source.
-	 * @return E_OK on success, E_DATABASE_ERROR on error 
-	 */
-	virtual am_Error_e getListMainSourceSoundProperties(const am_sourceID_t sourceID, std::vector<am_MainSoundProperty_s>& listSourceProperties) const =0;
-	/**
-	 * This is used to retrieve SourceClass Information of all source classes
-	 * @return E_OK on success, E_DATABASE_ERROR on error 
-	 */
-	virtual am_Error_e getListSourceClasses(std::vector<am_SourceClass_s>& listSourceClasses) const =0;
-	/**
-	 * This is used to retrieve SinkClass Information of all sink classes
-	 * @return E_OK on success, E_DATABASE_ERROR on error 
-	 */
-	virtual am_Error_e getListSinkClasses(std::vector<am_SinkClass_s>& listSinkClasses) const =0;
-	/**
-	 * Retrieves a complete list of all systemProperties.
-	 * @return E_OK on success, E_DATABASE_ERROR on error 
-	 */
-	virtual am_Error_e getListSystemProperties(std::vector<am_SystemProperty_s>& listSystemProperties) const =0;
-	/**
-	 * returns the delay in ms that the audiopath for the given mainConnection has
-	 * @return E_OK on success, E_NOT_POSSIBLE if timing information is not yet
-	 * retrieved, E_DATABASE_ERROR on read error on the database
-	 */
-	virtual am_Error_e getTimingInformation(const am_mainConnectionID_t mainConnectionID, am_timeSync_t& delay) const =0;
-	/**
-	 * this function is used to retrieve a pointer to the dBusConnectionWrapper
-	 * @return E_OK if pointer is valid, E_UKNOWN if AudioManager was compiled without
-	 * DBus Support
-	 */
-	virtual am_Error_e getDBusConnectionWrapper(CAmDbusWrapper*& dbusConnectionWrapper) const =0;
-	/**
-	 * This function returns the pointer to the socketHandler. This can be used to
-	 * integrate socket-based activites like communication with the mainloop of the
-	 * AudioManager.
-	 * returns E_OK if pointer is valid, E_UNKNOWN in case AudioManager was compiled
-	 * without socketHandler support,
-	 */
-	virtual am_Error_e getSocketHandler(CAmSocketHandler*& socketHandler) const =0;
-	/**
-	 * asynchronous confirmation of setCommandReady.
-	 */
-	virtual void confirmCommandReady(const uint16_t handle, const am_Error_e error) =0;
-	/**
-	 * asynchronous confirmation of setCommandRundown
-	 */
-	virtual void confirmCommandRundown(const uint16_t handle, const am_Error_e error) =0;
-	/**
-	 * Retrieves the list of MainNotifications for a sink. Does not return the
-	 * possible ones.
-	 */
-	virtual am_Error_e getListMainSinkNotificationConfigurations(const am_sinkID_t sinkID, std::vector<am_NotificationConfiguration_s>& listMainNotificationConfigurations) const =0;
-	/**
-	 * Retrieves the list of MainNotifications for a source. Does not return the
-	 * possible ones.
-	 */
-	virtual am_Error_e getListMainSourceNotificationConfigurations(const am_sourceID_t sourceID, std::vector<am_NotificationConfiguration_s>& listMainNotificationConfigurations) const =0;
-	/**
-	 * sets a MainNotificationConfiuration. This can be used to turn on an off
-	 * notifications an to change the mode of the configuration.
-	 * @return E_OK on success, E_NON_EXISTENT if sinkID does not exists,
-	 * E_DATABASE_ERROR on error 
-	 */
-	virtual am_Error_e setMainSinkNotificationConfiguration(const am_sinkID_t sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
-	/**
-	 * sets a MainNotificationConfiuration. This can be used to turn on an off
-	 * notifications an to change the mode of the configuration.
-	 * @return E_OK on success, E_NON_EXISTENT if sourceID does not exists,
-	 * E_DATABASE_ERROR on error 
-	 */
-	virtual am_Error_e setMainSourceNotificationConfiguration(const am_sourceID_t sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
-
-};
-
-/**
- * This interface handles all communication from the AudioManagerDaemon towards
- * the system. It is designed in such a way that only callbacks with no return
- * types are implemented. So when the CommandInterfacePlugins are designed in such
- * a way that they broadcast signals to any node who is interested in the
- * particular information (like signals on Dbus for example), more information can
- * be retrieved via the CommandReceiveInterface.
- * There are two rules that have to be kept in mind when implementing against this
- * interface:\n
- * \warning
- * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
- * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
- * CALL THAT EXPECTS A RETURN VALUE.\n
- * \details
- * Violation these rules may lead to unexpected behavior! Nevertheless you can
- * implement thread safe by using the deferred-call pattern described on the wiki
- * which also helps to implement calls that are forbidden.\n
- * For more information, please check CAmSerializer
- */
-class IAmCommandSend
-{
-
-public:
-	IAmCommandSend() {
-
-	}
-
-	virtual ~IAmCommandSend() {
-
-	}
-
-	/**
-	 * returns the interface version as string.
-	 */
-	virtual void getInterfaceVersion(std::string& version) const =0;
-	/**
-	 * This command starts the interface, the plugin itself. This is not meant to
-	 * start communication with the HMI itself. It is a good idea to implement here
-	 * everything that sets up the basic communication like DbusCommunication etc...
-	 * Be aware of side effects with systemd and socketbased communication!
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e startupInterface(IAmCommandReceive* commandreceiveinterface) =0;
-	/**
-	 * This function will indirectly be called by the Controller and is used to start
-	 * the Communication. Before this command, all communication will be ignored by
-	 * the AudioManager.
-	 * After the Plugin is ready, it will asynchronously answer with
-	 * condfirmCommandReady, the handle that is handed over must be returned.
-	 */
-	virtual void setCommandReady(const uint16_t handle) =0;
-	/**
-	 * This function will indirectly be called by the Controller and is used to stop
-	 * the Communication. After this command, all communication will be ignored by the
-	 * AudioManager. The plugin has to be prepared that either the power will be
-	 * switched off or the Interface is started again with setCommandReady
-	 * After the Plugin is ready to rundown, it will asynchronously answer with
-	 * condfirmCommandRundown, the handle that is handed over must be returned.
-	 */
-	virtual void setCommandRundown(const uint16_t handle) =0;
-	/**
-	 * Callback that is called when the number of connections change
-	 */
-	virtual void cbNewMainConnection(const am_MainConnectionType_s& mainConnection) =0;
-	/**
-	 * Callback that is called when the number of connections change
-	 */
-	virtual void cbRemovedMainConnection(const am_mainConnectionID_t mainConnection) =0;
-	/**
-	 * Callback that is called when the number of sinks change
-	 */
-	virtual void cbNewSink(const am_SinkType_s& sink) =0;
-	/**
-	 * Callback that is called when the number of sinks change
-	 */
-	virtual void cbRemovedSink(const am_sinkID_t sinkID) =0;
-	/**
-	 * Callback that is called when the number of sources change
-	 */
-	virtual void cbNewSource(const am_SourceType_s& source) =0;
-	/**
-	 * Callback that is called when the number of sources change
-	 */
-	virtual void cbRemovedSource(const am_sourceID_t source) =0;
-	/**
-	 * this callback is fired if the number of sink classes changed
-	 */
-	virtual void cbNumberOfSinkClassesChanged() =0;
-	/**
-	 * this callback is fired if the number of source classes changed
-	 */
-	virtual void cbNumberOfSourceClassesChanged() =0;
-	/**
-	 * This callback is called when the ConnectionState of a connection changed.
-	 */
-	virtual void cbMainConnectionStateChanged(const am_mainConnectionID_t connectionID, const am_ConnectionState_e connectionState) =0;
-	/**
+	virtual am_Error_e getListMainConnections(std::vector<am_MainConnectionType_s>& listConnections) const =0;
+	/**
+	 * returns the actual list of Sinks
+	 * @return E_OK on success, E_DATABASE_ERROR on error 
+	 */
+	virtual am_Error_e getListMainSinks(std::vector<am_SinkType_s>& listMainSinks) const =0;
+	/**
+	 * returns the actual list of Sources
+	 * @return E_OK on success, E_DATABASE_ERROR on error 
+	 */
+	virtual am_Error_e getListMainSources(std::vector<am_SourceType_s>& listMainSources) const =0;
+	/**
+	 * This is used to retrieve all source sound properties related to a source.
+	 * Returns a vector of the sound properties and values as pair
+	 * @return E_OK on success, E_DATABASE_ERROR on error 
+	 */
+	virtual am_Error_e getListMainSinkSoundProperties(const am_sinkID_t sinkID, std::vector<am_MainSoundProperty_s>& listSoundProperties) const =0;
+	/**
+	 * This is used to retrieve all source sound properties related to a source.
+	 * @return E_OK on success, E_DATABASE_ERROR on error 
+	 */
+	virtual am_Error_e getListMainSourceSoundProperties(const am_sourceID_t sourceID, std::vector<am_MainSoundProperty_s>& listSourceProperties) const =0;
+	/**
+	 * This is used to retrieve SourceClass Information of all source classes
+	 * @return E_OK on success, E_DATABASE_ERROR on error 
+	 */
+	virtual am_Error_e getListSourceClasses(std::vector<am_SourceClass_s>& listSourceClasses) const =0;
+	/**
+	 * This is used to retrieve SinkClass Information of all sink classes
+	 * @return E_OK on success, E_DATABASE_ERROR on error 
+	 */
+	virtual am_Error_e getListSinkClasses(std::vector<am_SinkClass_s>& listSinkClasses) const =0;
+	/**
+	 * Retrieves a complete list of all systemProperties.
+	 * @return E_OK on success, E_DATABASE_ERROR on error 
+	 */
+	virtual am_Error_e getListSystemProperties(std::vector<am_SystemProperty_s>& listSystemProperties) const =0;
+	/**
+	 * returns the delay in ms that the audiopath for the given mainConnection has
+	 * @return E_OK on success, E_NOT_POSSIBLE if timing information is not yet
+	 * retrieved, E_DATABASE_ERROR on read error on the database
+	 */
+	virtual am_Error_e getTimingInformation(const am_mainConnectionID_t mainConnectionID, am_timeSync_t& delay) const =0;
+	/**
+	 * this function is used to retrieve a pointer to the dBusConnectionWrapper
+	 * @return E_OK if pointer is valid, E_UKNOWN if AudioManager was compiled without
+	 * DBus Support
+	 */
+	virtual am_Error_e getDBusConnectionWrapper(CAmDbusWrapper*& dbusConnectionWrapper) const =0;
+	/**
+	 * This function returns the pointer to the socketHandler. This can be used to
+	 * integrate socket-based activites like communication with the mainloop of the
+	 * AudioManager.
+	 * returns E_OK if pointer is valid, E_UNKNOWN in case AudioManager was compiled
+	 * without socketHandler support,
+	 */
+	virtual am_Error_e getSocketHandler(CAmSocketHandler*& socketHandler) const =0;
+	/**
+	 * asynchronous confirmation of setCommandReady.
+	 */
+	virtual void confirmCommandReady(const uint16_t handle, const am_Error_e error) =0;
+	/**
+	 * asynchronous confirmation of setCommandRundown
+	 */
+	virtual void confirmCommandRundown(const uint16_t handle, const am_Error_e error) =0;
+	/**
+	 * Retrieves the list of MainNotifications for a sink. Does not return the
+	 * possible ones.
+	 */
+	virtual am_Error_e getListMainSinkNotificationConfigurations(const am_sinkID_t sinkID, std::vector<am_NotificationConfiguration_s>& listMainNotificationConfigurations) const =0;
+	/**
+	 * Retrieves the list of MainNotifications for a source. Does not return the
+	 * possible ones.
+	 */
+	virtual am_Error_e getListMainSourceNotificationConfigurations(const am_sourceID_t sourceID, std::vector<am_NotificationConfiguration_s>& listMainNotificationConfigurations) const =0;
+	/**
+	 * sets a MainNotificationConfiuration. This can be used to turn on an off
+	 * notifications an to change the mode of the configuration.
+	 * @return E_OK on success, E_NON_EXISTENT if sinkID does not exists,
+	 * E_DATABASE_ERROR on error 
+	 */
+	virtual am_Error_e setMainSinkNotificationConfiguration(const am_sinkID_t sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
+	/**
+	 * sets a MainNotificationConfiuration. This can be used to turn on an off
+	 * notifications an to change the mode of the configuration.
+	 * @return E_OK on success, E_NON_EXISTENT if sourceID does not exists,
+	 * E_DATABASE_ERROR on error 
+	 */
+	virtual am_Error_e setMainSourceNotificationConfiguration(const am_sourceID_t sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
+
+};
+
+/**
+ * This interface handles all communication from the AudioManagerDaemon towards
+ * the system. It is designed in such a way that only callbacks with no return
+ * types are implemented. So when the CommandInterfacePlugins are designed in such
+ * a way that they broadcast signals to any node who is interested in the
+ * particular information (like signals on Dbus for example), more information can
+ * be retrieved via the CommandReceiveInterface.
+ * There are two rules that have to be kept in mind when implementing against this
+ * interface:\n
+ * \warning
+ * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
+ * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
+ * CALL THAT EXPECTS A RETURN VALUE.\n
+ * \details
+ * Violation these rules may lead to unexpected behavior! Nevertheless you can
+ * implement thread safe by using the deferred-call pattern described on the wiki
+ * which also helps to implement calls that are forbidden.\n
+ * For more information, please check CAmSerializer
+ */
+class IAmCommandSend
+{
+
+public:
+	IAmCommandSend() {
+
+	}
+
+	virtual ~IAmCommandSend() {
+
+	}
+
+	/**
+	 * returns the interface version as string.
+	 */
+	virtual void getInterfaceVersion(std::string& version) const =0;
+	/**
+	 * This command starts the interface, the plugin itself. This is not meant to
+	 * start communication with the HMI itself. It is a good idea to implement here
+	 * everything that sets up the basic communication like DbusCommunication etc...
+	 * Be aware of side effects with systemd and socketbased communication!
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e startupInterface(IAmCommandReceive* commandreceiveinterface) =0;
+	/**
+	 * This function will indirectly be called by the Controller and is used to start
+	 * the Communication. Before this command, all communication will be ignored by
+	 * the AudioManager.
+	 * After the Plugin is ready, it will asynchronously answer with
+	 * condfirmCommandReady, the handle that is handed over must be returned.
+	 */
+	virtual void setCommandReady(const uint16_t handle) =0;
+	/**
+	 * This function will indirectly be called by the Controller and is used to stop
+	 * the Communication. After this command, all communication will be ignored by the
+	 * AudioManager. The plugin has to be prepared that either the power will be
+	 * switched off or the Interface is started again with setCommandReady
+	 * After the Plugin is ready to rundown, it will asynchronously answer with
+	 * condfirmCommandRundown, the handle that is handed over must be returned.
+	 */
+	virtual void setCommandRundown(const uint16_t handle) =0;
+	/**
+	 * Callback that is called when the number of connections change
+	 */
+	virtual void cbNewMainConnection(const am_MainConnectionType_s& mainConnection) =0;
+	/**
+	 * Callback that is called when the number of connections change
+	 */
+	virtual void cbRemovedMainConnection(const am_mainConnectionID_t mainConnection) =0;
+	/**
+	 * Callback that is called when the number of sinks change
+	 */
+	virtual void cbNewSink(const am_SinkType_s& sink) =0;
+	/**
+	 * Callback that is called when the number of sinks change
+	 */
+	virtual void cbRemovedSink(const am_sinkID_t sinkID) =0;
+	/**
+	 * Callback that is called when the number of sources change
+	 */
+	virtual void cbNewSource(const am_SourceType_s& source) =0;
+	/**
+	 * Callback that is called when the number of sources change
+	 */
+	virtual void cbRemovedSource(const am_sourceID_t source) =0;
+	/**
+	 * this callback is fired if the number of sink classes changed
+	 */
+	virtual void cbNumberOfSinkClassesChanged() =0;
+	/**
+	 * this callback is fired if the number of source classes changed
+	 */
+	virtual void cbNumberOfSourceClassesChanged() =0;
+	/**
+	 * This callback is called when the ConnectionState of a connection changed.
+	 */
+	virtual void cbMainConnectionStateChanged(const am_mainConnectionID_t connectionID, const am_ConnectionState_e connectionState) =0;
+	/**
 	 * this callback indicates that a source has changed.
 	 */
 	virtual void cbMainSourceChanged(const am_sourceID_t sourceID) =0;
 	/**
 	 * this callback indicates that a sinkSoundProperty has changed.
-	 */
-	virtual void cbMainSinkSoundPropertyChanged(const am_sinkID_t sinkID, const am_MainSoundProperty_s& soundProperty) =0;
-	/**
-	 * this callback indicates that a sourceSoundProperty has changed.
-	 */
-	virtual void cbMainSourceSoundPropertyChanged(const am_sourceID_t sourceID, const am_MainSoundProperty_s& soundProperty) =0;
-	/**
-	 * this callback is called when the availability of a sink has changed
-	 */
-	virtual void cbSinkAvailabilityChanged(const am_sinkID_t sinkID, const am_Availability_s& availability) =0;
-	/**
-	 * this callback is called when the availability of source has changed.
-	 */
-	virtual void cbSourceAvailabilityChanged(const am_sourceID_t sourceID, const am_Availability_s& availability) =0;
-	/**
-	 * this callback indicates a volume change on the indicated sink
-	 */
-	virtual void cbVolumeChanged(const am_sinkID_t sinkID, const am_mainVolume_t volume) =0;
+	 */
+	virtual void cbMainSinkSoundPropertyChanged(const am_sinkID_t sinkID, const am_MainSoundProperty_s& soundProperty) =0;
+	/**
+	 * this callback indicates that a sourceSoundProperty has changed.
+	 */
+	virtual void cbMainSourceSoundPropertyChanged(const am_sourceID_t sourceID, const am_MainSoundProperty_s& soundProperty) =0;
+	/**
+	 * this callback is called when the availability of a sink has changed
+	 */
+	virtual void cbSinkAvailabilityChanged(const am_sinkID_t sinkID, const am_Availability_s& availability) =0;
+	/**
+	 * this callback is called when the availability of source has changed.
+	 */
+	virtual void cbSourceAvailabilityChanged(const am_sourceID_t sourceID, const am_Availability_s& availability) =0;
+	/**
+	 * this callback indicates a volume change on the indicated sink
+	 */
+	virtual void cbVolumeChanged(const am_sinkID_t sinkID, const am_mainVolume_t volume) =0;
 	/**
 	 * this callback indicates a volume change on the indicated source
 	 */
 	virtual void cbSourceVolumeChanged(const am_sourceID_t sourceID, const am_mainVolume_t volume) =0;
-	/**
-	 * this callback indicates a mute state change on a sink.
-	 */
-	virtual void cbSinkMuteStateChanged(const am_sinkID_t sinkID, const am_MuteState_e muteState) =0;
-	/**
-	 * is fired if a systemProperty changed
-	 */
-	virtual void cbSystemPropertyChanged(const am_SystemProperty_s& systemProperty) =0;
-	/**
-	 * This callback is fired if the timinginformation for a mainConnectionID changed
-	 */
-	virtual void cbTimingInformationChanged(const am_mainConnectionID_t mainConnectionID, const am_timeSync_t time) =0;
-	/**
-	 * This callback is called when a sink is updated.
-	 */
-	virtual void cbSinkUpdated(const am_sinkID_t sinkID, const am_sinkClass_t sinkClassID, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
-	/**
-	 * This callback is called when a source is updated.
-	 */
-	virtual void cbSourceUpdated(const am_sourceID_t sourceID, const am_sourceClass_t sourceClassID, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
-	/**
-	 * This callback is called when a notificated value of a sink changes.
-	 */
-	virtual void cbSinkNotification(const am_sinkID_t sinkID, const am_NotificationPayload_s& notification) =0;
-	/**
-	 * This callback is called when a notifcated value of a source changes.
-	 */
-	virtual void cbSourceNotification(const am_sourceID_t sourceID, const am_NotificationPayload_s& notification) =0;
-	/**
-	 * This callback is triggered when a mainNotificationConfiguration is changed.
-	 */
-	virtual void cbMainSinkNotificationConfigurationChanged(const am_sinkID_t sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
-	/**
-	 * This callback is triggered when a mainNotificationConfiguration is changed.
-	 */
-	virtual void cbMainSourceNotificationConfigurationChanged(const am_sourceID_t sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
-
-};
-}
-#endif // !defined(EA_D9D48C0D_77EC_4fa7_B861_1827740C7ECA__INCLUDED_)
+	/**
+	 * this callback indicates a mute state change on a sink.
+	 */
+	virtual void cbSinkMuteStateChanged(const am_sinkID_t sinkID, const am_MuteState_e muteState) =0;
+	/**
+	 * is fired if a systemProperty changed
+	 */
+	virtual void cbSystemPropertyChanged(const am_SystemProperty_s& systemProperty) =0;
+	/**
+	 * This callback is fired if the timinginformation for a mainConnectionID changed
+	 */
+	virtual void cbTimingInformationChanged(const am_mainConnectionID_t mainConnectionID, const am_timeSync_t time) =0;
+	/**
+	 * This callback is called when a sink is updated.
+	 */
+	virtual void cbSinkUpdated(const am_sinkID_t sinkID, const am_sinkClass_t sinkClassID, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
+	/**
+	 * This callback is called when a source is updated.
+	 */
+	virtual void cbSourceUpdated(const am_sourceID_t sourceID, const am_sourceClass_t sourceClassID, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
+	/**
+	 * This callback is called when a notificated value of a sink changes.
+	 */
+	virtual void cbSinkNotification(const am_sinkID_t sinkID, const am_NotificationPayload_s& notification) =0;
+	/**
+	 * This callback is called when a notifcated value of a source changes.
+	 */
+	virtual void cbSourceNotification(const am_sourceID_t sourceID, const am_NotificationPayload_s& notification) =0;
+	/**
+	 * This callback is triggered when a mainNotificationConfiguration is changed.
+	 */
+	virtual void cbMainSinkNotificationConfigurationChanged(const am_sinkID_t sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
+	/**
+	 * This callback is triggered when a mainNotificationConfiguration is changed.
+	 */
+	virtual void cbMainSourceNotificationConfigurationChanged(const am_sourceID_t sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
+
+};
+}
+#endif // !defined(EA_D9D48C0D_77EC_4fa7_B861_1827740C7ECA__INCLUDED_)
diff --git a/include/IAmControl.h b/include/IAmControl.h
index f1f7b20..d10e04b 100644
--- a/include/IAmControl.h
+++ b/include/IAmControl.h
@@ -1,282 +1,282 @@
-/**
- * Copyright (C) 2012 - 2014, BMW AG
- *
- * This file is part of GENIVI Project AudioManager.
- *
- * Contributions are licensed to the GENIVI Alliance under one or more
- * Contribution License Agreements.
- *
- * \copyright
- * This Source Code Form is subject to the terms of the
- * Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
- * this file, You can obtain one at http://mozilla.org/MPL/2.0/.
- *
- *
- * \author Christian Linke, christian.linke@bmw.de BMW 2011 - 2014
- *
- * \file
- * For further information see http://projects.genivi.org/audio-manager
- *
- * THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. 
- * PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN.
- */
-#if !defined(EA_69597D9E_B0A3_4c6d_BBB6_E7F436B8B799__INCLUDED_)
-#define EA_69597D9E_B0A3_4c6d_BBB6_E7F436B8B799__INCLUDED_
-
-#include <vector>
-#include <string>
-#include "audiomanagertypes.h"
-namespace am {
-class CAmSocketHandler;
-}
-
-#include "NodeStateManager.h"
-
-#include "audiomanagertypes.h"
-
-#define ControlVersion "4.0" 
-namespace am {
-
-/**
- * This interface gives access to all important functions of the audiomanager that
- * are used by the AudioManagerController to control the system.
- * There are two rules that have to be kept in mind when implementing against this
- * interface:\n
- * \warning
- * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
- * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
- * CALL THAT EXPECTS A RETURN VALUE.\n
- * \details
- * Violation these rules may lead to unexpected behavior! Nevertheless you can
- * implement thread safe by using the deferred-call pattern described on the wiki
- * which also helps to implement calls that are forbidden.\n
- * For more information, please check CAmSerializer
- */
-class IAmControlReceive
-{
-
-public:
-	IAmControlReceive() {
-
-	}
-
-	virtual ~IAmControlReceive() {
-
-	}
-
-	/**
-	 * This function returns the version of the interface
-	 */
-	virtual void getInterfaceVersion(std::string& version) const =0;
-	/**
-	 * calculates a route from source to sink.
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e getRoute(const bool onlyfree, const am_sourceID_t sourceID, const am_sinkID_t sinkID, std::vector<am_Route_s>& returnList) =0;
-	/**
-	 * With this function, elementary connects can be triggered by the controller.
-	 * @return E_OK on success, E_UNKNOWN on error, E_WRONG_FORMAT of
-	 * connectionFormats do not match, E_NO_CHANGE if the desired connection is
-	 * already build up
-	 */
-	virtual am_Error_e connect(am_Handle_s& handle, am_connectionID_t& connectionID, const am_CustomConnectionFormat_t format, const am_sourceID_t sourceID, const am_sinkID_t sinkID) =0;
-	/**
-	 * is used to disconnect a connection
-	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if connection was
-	 * not found, E_NO_CHANGE if no change is neccessary
-	 */
-	virtual am_Error_e disconnect(am_Handle_s& handle, const am_connectionID_t connectionID) =0;
-	/**
-	 * triggers a cross fade.
-	 * @return E_OK on success, E_UNKNOWN on error E_NO_CHANGE if no change is
-	 * neccessary
-	 */
-	virtual am_Error_e crossfade(am_Handle_s& handle, const am_HotSink_e hotSource, const am_crossfaderID_t crossfaderID, const am_CustomRampType_t rampType, const am_time_t rampTime) =0;
-	/**
-	 * with this method, all actions that have a handle assigned can be stopped.
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e abortAction(const am_Handle_s handle) =0;
-	/**
-	 * this method sets a source state for a source. This function will trigger the
-	 * callback cbAckSetSourceState
-	 * @return E_OK on success, E_NO_CHANGE if the desired value is already correct,
-	 * E_UNKNOWN on error, E_NO_CHANGE if no change is neccessary 
-	 */
-	virtual am_Error_e setSourceState(am_Handle_s& handle, const am_sourceID_t sourceID, const am_SourceState_e state) =0;
-	/**
-	 * with this function, setting of sinks volumes is done. The behavior of the
-	 * volume set is depended on the given ramp and time information.
-	 * This function is not only used to ramp volume, but also to mute and direct set
-	 * the level. Exact behavior is depended on the selected mute ramps.
-	 * @return E_OK on success, E_NO_CHANGE if the volume is already on the desired
-	 * value, E_OUT_OF_RANGE is the volume is out of range, E_UNKNOWN on every other
-	 * error.
-	 */
-	virtual am_Error_e setSinkVolume(am_Handle_s& handle, const am_sinkID_t sinkID, const am_volume_t volume, const am_CustomRampType_t ramp, const am_time_t time) =0;
-	/**
-	 * with this function, setting of source volumes is done. The behavior of the
-	 * volume set is depended on the given ramp and time information.
-	 * This function is not only used to ramp volume, but also to mute and direct set
-	 * the level. Exact behavior is depended on the selected mute ramps.
-	 * @return E_OK on success, E_NO_CHANGE if the volume is already on the desired
-	 * value, E_OUT_OF_RANGE is the volume is out of range, E_UNKNOWN on every other
-	 * error.
-	 */
-	virtual am_Error_e setSourceVolume(am_Handle_s& handle, const am_sourceID_t sourceID, const am_volume_t volume, const am_CustomRampType_t rampType, const am_time_t time) =0;
-	/**
-	 * is used to set several sinkSoundProperties at a time
-	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE  if property is out
-	 * of range, E_NO_CHANGE if no change is neccessary
-	 */
-	virtual am_Error_e setSinkSoundProperties(am_Handle_s& handle, const am_sinkID_t sinkID, const std::vector<am_SoundProperty_s>& soundProperty) =0;
-	/**
-	 * is used to set sinkSoundProperties
-	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE  if property is out
-	 * of range, E_NO_CHANGE if no change is neccessary
-	 */
-	virtual am_Error_e setSinkSoundProperty(am_Handle_s& handle, const am_sinkID_t sinkID, const am_SoundProperty_s& soundProperty) =0;
-	/**
-	 * is used to set several SourceSoundProperties at a time
-	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE  if property is out
-	 * of range. E_NO_CHANGE if no change is neccessary
-	 */
-	virtual am_Error_e setSourceSoundProperties(am_Handle_s& handle, const am_sourceID_t sourceID, const std::vector<am_SoundProperty_s>& soundProperty) =0;
-	/**
-	 * is used to set sourceSoundProperties
-	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE  if property is out
-	 * of range. E_NO_CHANGE if no change is neccessary
-	 */
-	virtual am_Error_e setSourceSoundProperty(am_Handle_s& handle, const am_sourceID_t sourceID, const am_SoundProperty_s& soundProperty) =0;
-	/**
-	 * sets the domain state of a domain
-	 * @return E_OK on success, E_UNKNOWN on error, E_NO_CHANGE if no change is
-	 * neccessary
-	 */
-	virtual am_Error_e setDomainState(const am_domainID_t domainID, const am_DomainState_e domainState) =0;
-	/**
-	 * enters a domain in the database, creates and ID
-	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
-	 * database, E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e enterDomainDB(const am_Domain_s& domainData, am_domainID_t& domainID) =0;
-	/**
-	 * enters a mainconnection in the database, creates and ID
-	 * @return E_OK on success, E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e enterMainConnectionDB(const am_MainConnection_s& mainConnectionData, am_mainConnectionID_t& connectionID) =0;
-	/**
-	 * enters a sink in the database.
-	 * The sinkID in am_Sink_s shall be 0 in case of a dynamic added source A sinkID
-	 * greater than 100 will be assigned. If a specific sinkID with a value <100 is
-	 * given, the given value will be used. This is for a static setup where the ID's
-	 * are predefined.
-	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
-	 * database, E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e enterSinkDB(const am_Sink_s& sinkData, am_sinkID_t& sinkID) =0;
-	/**
-	 * enters a crossfader in the database.
-	 * The crossfaderID in am_Crossfader_s shall be 0 in case of a dynamic added
-	 * source A crossfaderID greater than 100 will be assigned. If a specific
-	 * crossfaderID with a value <100 is given, the given value will be used. This is
-	 * for a static setup where the ID's are predefined.
-	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
-	 * database, E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e enterCrossfaderDB(const am_Crossfader_s& crossfaderData, am_crossfaderID_t& crossfaderID) =0;
-	/**
-	 * enters a gateway in the database.
-	 * The gatewayID in am_Gateway_s shall be 0 in case of a dynamic added source A
-	 * gatewayID greater than 100 will be assigned. If a specific gatewayID with a
-	 * value <100 is given, the given value will be used. This is for a static setup
-	 * where the ID's are predefined.
-	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
-	 * database, E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e enterGatewayDB(const am_Gateway_s& gatewayData, am_gatewayID_t& gatewayID) =0;
-	/**
-	 * enters a converter in the database.
-	 * The converterID in am_Converter_s shall be 0 in case of a dynamic added source
-	 * A converterID greater than 100 will be assigned. If a specific gatewayID with a
-	 * value <100 is given, the given value will be used. This is for a static setup
-	 * where the ID's are predefined.
-	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
-	 * database, E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e enterConverterDB(const am_Converter_s& converterData, am_converterID_t& converterID) =0;
-	/**
-	 * enters a source in the database.
-	 * The sourceID in am_Source_s shall be 0 in case of a dynamic added source A
-	 * sourceID greater than 100 will be assigned. If a specific sourceID with a value
-	 * <100 is given, the given value will be used. This is for a static setup where
-	 * the ID's are predefined.
-	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
-	 * database, E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e enterSourceDB(const am_Source_s& sourceData, am_sourceID_t& sourceID) =0;
-	/**
-	 * Enters a sourceClass into the database.
-	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
-	 * database, E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e enterSinkClassDB(const am_SinkClass_s& sinkClass, am_sinkClass_t& sinkClassID) =0;
-	/**
-	 * Enters a sourceClass into the database.
-	 * The sourceClassID in am_sourceClass_s shall be 0 in case of a dynamic added
-	 * source A sourceClassID greater than 100 will be assigned. If a specific
-	 * sourceClassID with a value <100 is given, the given value will be used. This is
-	 * for a static setup where the ID's are predefined.
-	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
-	 * database, E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e enterSourceClassDB(am_sourceClass_t& sourceClassID, const am_SourceClass_s& sourceClass) =0;
-	/**
-	 * changes class information of a sinkclass.
-	 * The properties will overwrite the values of the sinkClassID given in the
-	 * sinkClass.
-	 * It is the duty of the controller to check if the property is valid. If it does
-	 * not exist, the daemon will not return an error.
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if
-	 * sinkClassID was not found. 
-	 */
-	virtual am_Error_e changeSinkClassInfoDB(const am_SinkClass_s& sinkClass) =0;
-	/**
-	 * changes class information of a sourceClass.
-	 * The properties will overwrite the values of the sourceClassID given in the
-	 * sourceClass.
-	 * It is the duty of the controller to check if the property is valid. If it does
-	 * not exist, the daemon will not return an error.
-	 * @return E_OK on success, E_DATABASE_ERROR on error and E_NON_EXISTENT if the
-	 * ClassID does not exist.
-	 */
-	virtual am_Error_e changeSourceClassInfoDB(const am_SourceClass_s& sourceClass) =0;
-	/**
-	 * This function is used to enter the system Properties into the database.
-	 * All entries in the database will be erased before entering the new List. It
-	 * should only be called once at system startup.
-	 * @return E_OK on success,  E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e enterSystemPropertiesListDB(const std::vector<am_SystemProperty_s>& listSystemProperties) =0;
-	/**
-	 * changes the mainConnectionState of MainConnection
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if
-	 * mainconnection
-	 */
-	virtual am_Error_e changeMainConnectionRouteDB(const am_mainConnectionID_t mainconnectionID, const std::vector<am_connectionID_t>& listConnectionID) =0;
-	/**
-	 * changes the mainConnectionState of MainConnection
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if
-	 * mainconnection
-	 */
-	virtual am_Error_e changeMainConnectionStateDB(const am_mainConnectionID_t mainconnectionID, const am_ConnectionState_e connectionState) =0;
-	/**
-	 * changes the sink volume of a sink
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
-	 * not found
-	 */
-	virtual am_Error_e changeSinkMainVolumeDB(const am_mainVolume_t mainVolume, const am_sinkID_t sinkID) =0;
-	/**
+/**
+ * Copyright (C) 2012 - 2014, BMW AG
+ *
+ * This file is part of GENIVI Project AudioManager.
+ *
+ * Contributions are licensed to the GENIVI Alliance under one or more
+ * Contribution License Agreements.
+ *
+ * \copyright
+ * This Source Code Form is subject to the terms of the
+ * Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
+ * this file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ *
+ * \author Christian Linke, christian.linke@bmw.de BMW 2011 - 2014
+ *
+ * \file
+ * For further information see http://projects.genivi.org/audio-manager
+ *
+ * THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. 
+ * PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN.
+ */
+#if !defined(EA_69597D9E_B0A3_4c6d_BBB6_E7F436B8B799__INCLUDED_)
+#define EA_69597D9E_B0A3_4c6d_BBB6_E7F436B8B799__INCLUDED_
+
+#include <vector>
+#include <string>
+#include "audiomanagertypes.h"
+namespace am {
+class CAmSocketHandler;
+}
+
+#include "NodeStateManager.h"
+
+#include "audiomanagertypes.h"
+
+#define ControlVersion "4.0" 
+namespace am {
+
+/**
+ * This interface gives access to all important functions of the audiomanager that
+ * are used by the AudioManagerController to control the system.
+ * There are two rules that have to be kept in mind when implementing against this
+ * interface:\n
+ * \warning
+ * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
+ * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
+ * CALL THAT EXPECTS A RETURN VALUE.\n
+ * \details
+ * Violation these rules may lead to unexpected behavior! Nevertheless you can
+ * implement thread safe by using the deferred-call pattern described on the wiki
+ * which also helps to implement calls that are forbidden.\n
+ * For more information, please check CAmSerializer
+ */
+class IAmControlReceive
+{
+
+public:
+	IAmControlReceive() {
+
+	}
+
+	virtual ~IAmControlReceive() {
+
+	}
+
+	/**
+	 * This function returns the version of the interface
+	 */
+	virtual void getInterfaceVersion(std::string& version) const =0;
+	/**
+	 * calculates a route from source to sink.
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e getRoute(const bool onlyfree, const am_sourceID_t sourceID, const am_sinkID_t sinkID, std::vector<am_Route_s>& returnList) =0;
+	/**
+	 * With this function, elementary connects can be triggered by the controller.
+	 * @return E_OK on success, E_UNKNOWN on error, E_WRONG_FORMAT of
+	 * connectionFormats do not match, E_NO_CHANGE if the desired connection is
+	 * already build up
+	 */
+	virtual am_Error_e connect(am_Handle_s& handle, am_connectionID_t& connectionID, const am_CustomConnectionFormat_t format, const am_sourceID_t sourceID, const am_sinkID_t sinkID) =0;
+	/**
+	 * is used to disconnect a connection
+	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if connection was
+	 * not found, E_NO_CHANGE if no change is neccessary
+	 */
+	virtual am_Error_e disconnect(am_Handle_s& handle, const am_connectionID_t connectionID) =0;
+	/**
+	 * triggers a cross fade.
+	 * @return E_OK on success, E_UNKNOWN on error E_NO_CHANGE if no change is
+	 * neccessary
+	 */
+	virtual am_Error_e crossfade(am_Handle_s& handle, const am_HotSink_e hotSource, const am_crossfaderID_t crossfaderID, const am_CustomRampType_t rampType, const am_time_t rampTime) =0;
+	/**
+	 * with this method, all actions that have a handle assigned can be stopped.
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e abortAction(const am_Handle_s handle) =0;
+	/**
+	 * this method sets a source state for a source. This function will trigger the
+	 * callback cbAckSetSourceState
+	 * @return E_OK on success, E_NO_CHANGE if the desired value is already correct,
+	 * E_UNKNOWN on error, E_NO_CHANGE if no change is neccessary 
+	 */
+	virtual am_Error_e setSourceState(am_Handle_s& handle, const am_sourceID_t sourceID, const am_SourceState_e state) =0;
+	/**
+	 * with this function, setting of sinks volumes is done. The behavior of the
+	 * volume set is depended on the given ramp and time information.
+	 * This function is not only used to ramp volume, but also to mute and direct set
+	 * the level. Exact behavior is depended on the selected mute ramps.
+	 * @return E_OK on success, E_NO_CHANGE if the volume is already on the desired
+	 * value, E_OUT_OF_RANGE is the volume is out of range, E_UNKNOWN on every other
+	 * error.
+	 */
+	virtual am_Error_e setSinkVolume(am_Handle_s& handle, const am_sinkID_t sinkID, const am_volume_t volume, const am_CustomRampType_t ramp, const am_time_t time) =0;
+	/**
+	 * with this function, setting of source volumes is done. The behavior of the
+	 * volume set is depended on the given ramp and time information.
+	 * This function is not only used to ramp volume, but also to mute and direct set
+	 * the level. Exact behavior is depended on the selected mute ramps.
+	 * @return E_OK on success, E_NO_CHANGE if the volume is already on the desired
+	 * value, E_OUT_OF_RANGE is the volume is out of range, E_UNKNOWN on every other
+	 * error.
+	 */
+	virtual am_Error_e setSourceVolume(am_Handle_s& handle, const am_sourceID_t sourceID, const am_volume_t volume, const am_CustomRampType_t rampType, const am_time_t time) =0;
+	/**
+	 * is used to set several sinkSoundProperties at a time
+	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE  if property is out
+	 * of range, E_NO_CHANGE if no change is neccessary
+	 */
+	virtual am_Error_e setSinkSoundProperties(am_Handle_s& handle, const am_sinkID_t sinkID, const std::vector<am_SoundProperty_s>& soundProperty) =0;
+	/**
+	 * is used to set sinkSoundProperties
+	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE  if property is out
+	 * of range, E_NO_CHANGE if no change is neccessary
+	 */
+	virtual am_Error_e setSinkSoundProperty(am_Handle_s& handle, const am_sinkID_t sinkID, const am_SoundProperty_s& soundProperty) =0;
+	/**
+	 * is used to set several SourceSoundProperties at a time
+	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE  if property is out
+	 * of range. E_NO_CHANGE if no change is neccessary
+	 */
+	virtual am_Error_e setSourceSoundProperties(am_Handle_s& handle, const am_sourceID_t sourceID, const std::vector<am_SoundProperty_s>& soundProperty) =0;
+	/**
+	 * is used to set sourceSoundProperties
+	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE  if property is out
+	 * of range. E_NO_CHANGE if no change is neccessary
+	 */
+	virtual am_Error_e setSourceSoundProperty(am_Handle_s& handle, const am_sourceID_t sourceID, const am_SoundProperty_s& soundProperty) =0;
+	/**
+	 * sets the domain state of a domain
+	 * @return E_OK on success, E_UNKNOWN on error, E_NO_CHANGE if no change is
+	 * neccessary
+	 */
+	virtual am_Error_e setDomainState(const am_domainID_t domainID, const am_DomainState_e domainState) =0;
+	/**
+	 * enters a domain in the database, creates and ID
+	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
+	 * database, E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e enterDomainDB(const am_Domain_s& domainData, am_domainID_t& domainID) =0;
+	/**
+	 * enters a mainconnection in the database, creates and ID
+	 * @return E_OK on success, E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e enterMainConnectionDB(const am_MainConnection_s& mainConnectionData, am_mainConnectionID_t& connectionID) =0;
+	/**
+	 * enters a sink in the database.
+	 * The sinkID in am_Sink_s shall be 0 in case of a dynamic added source A sinkID
+	 * greater than 100 will be assigned. If a specific sinkID with a value <100 is
+	 * given, the given value will be used. This is for a static setup where the ID's
+	 * are predefined.
+	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
+	 * database, E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e enterSinkDB(const am_Sink_s& sinkData, am_sinkID_t& sinkID) =0;
+	/**
+	 * enters a crossfader in the database.
+	 * The crossfaderID in am_Crossfader_s shall be 0 in case of a dynamic added
+	 * source A crossfaderID greater than 100 will be assigned. If a specific
+	 * crossfaderID with a value <100 is given, the given value will be used. This is
+	 * for a static setup where the ID's are predefined.
+	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
+	 * database, E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e enterCrossfaderDB(const am_Crossfader_s& crossfaderData, am_crossfaderID_t& crossfaderID) =0;
+	/**
+	 * enters a gateway in the database.
+	 * The gatewayID in am_Gateway_s shall be 0 in case of a dynamic added source A
+	 * gatewayID greater than 100 will be assigned. If a specific gatewayID with a
+	 * value <100 is given, the given value will be used. This is for a static setup
+	 * where the ID's are predefined.
+	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
+	 * database, E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e enterGatewayDB(const am_Gateway_s& gatewayData, am_gatewayID_t& gatewayID) =0;
+	/**
+	 * enters a converter in the database.
+	 * The converterID in am_Converter_s shall be 0 in case of a dynamic added source
+	 * A converterID greater than 100 will be assigned. If a specific gatewayID with a
+	 * value <100 is given, the given value will be used. This is for a static setup
+	 * where the ID's are predefined.
+	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
+	 * database, E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e enterConverterDB(const am_Converter_s& converterData, am_converterID_t& converterID) =0;
+	/**
+	 * enters a source in the database.
+	 * The sourceID in am_Source_s shall be 0 in case of a dynamic added source A
+	 * sourceID greater than 100 will be assigned. If a specific sourceID with a value
+	 * <100 is given, the given value will be used. This is for a static setup where
+	 * the ID's are predefined.
+	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
+	 * database, E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e enterSourceDB(const am_Source_s& sourceData, am_sourceID_t& sourceID) =0;
+	/**
+	 * Enters a sourceClass into the database.
+	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
+	 * database, E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e enterSinkClassDB(const am_SinkClass_s& sinkClass, am_sinkClass_t& sinkClassID) =0;
+	/**
+	 * Enters a sourceClass into the database.
+	 * The sourceClassID in am_sourceClass_s shall be 0 in case of a dynamic added
+	 * source A sourceClassID greater than 100 will be assigned. If a specific
+	 * sourceClassID with a value <100 is given, the given value will be used. This is
+	 * for a static setup where the ID's are predefined.
+	 * @return E_OK on success, E_ALREADY_EXISTENT if the ID or name is already in the
+	 * database, E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e enterSourceClassDB(am_sourceClass_t& sourceClassID, const am_SourceClass_s& sourceClass) =0;
+	/**
+	 * changes class information of a sinkclass.
+	 * The properties will overwrite the values of the sinkClassID given in the
+	 * sinkClass.
+	 * It is the duty of the controller to check if the property is valid. If it does
+	 * not exist, the daemon will not return an error.
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if
+	 * sinkClassID was not found. 
+	 */
+	virtual am_Error_e changeSinkClassInfoDB(const am_SinkClass_s& sinkClass) =0;
+	/**
+	 * changes class information of a sourceClass.
+	 * The properties will overwrite the values of the sourceClassID given in the
+	 * sourceClass.
+	 * It is the duty of the controller to check if the property is valid. If it does
+	 * not exist, the daemon will not return an error.
+	 * @return E_OK on success, E_DATABASE_ERROR on error and E_NON_EXISTENT if the
+	 * ClassID does not exist.
+	 */
+	virtual am_Error_e changeSourceClassInfoDB(const am_SourceClass_s& sourceClass) =0;
+	/**
+	 * This function is used to enter the system Properties into the database.
+	 * All entries in the database will be erased before entering the new List. It
+	 * should only be called once at system startup.
+	 * @return E_OK on success,  E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e enterSystemPropertiesListDB(const std::vector<am_SystemProperty_s>& listSystemProperties) =0;
+	/**
+	 * changes the mainConnectionState of MainConnection
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if
+	 * mainconnection
+	 */
+	virtual am_Error_e changeMainConnectionRouteDB(const am_mainConnectionID_t mainconnectionID, const std::vector<am_connectionID_t>& listConnectionID) =0;
+	/**
+	 * changes the mainConnectionState of MainConnection
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if
+	 * mainconnection
+	 */
+	virtual am_Error_e changeMainConnectionStateDB(const am_mainConnectionID_t mainconnectionID, const am_ConnectionState_e connectionState) =0;
+	/**
+	 * changes the sink volume of a sink
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
+	 * not found
+	 */
+	virtual am_Error_e changeSinkMainVolumeDB(const am_mainVolume_t mainVolume, const am_sinkID_t sinkID) =0;
+	/**
 	 * changes the sink volume of a sink
 	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
 	 * not found
@@ -284,764 +284,764 @@ public:
 	virtual am_Error_e changeSourceMainVolumeDB(const am_mainVolume_t mainVolume, const am_sourceID_t sourceID) =0;
 	/**
 	 * changes the availablility of a source
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
-	 * not found
-	 */
-	virtual am_Error_e changeSinkAvailabilityDB(const am_Availability_s& availability, const am_sinkID_t sinkID) =0;
-	/**
-	 * changes the domainstate of a domain
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
-	 * was not found
-	 */
-	virtual am_Error_e changDomainStateDB(const am_DomainState_e domainState, const am_domainID_t domainID) =0;
-	/**
-	 * changes the mute state of a sink
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
-	 * not found 
-	 */
-	virtual am_Error_e changeSinkMuteStateDB(const am_MuteState_e muteState, const am_sinkID_t sinkID) =0;
-	/**
-	 * changes the mainsinksoundproperty of a sink
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
-	 * not found
-	 */
-	virtual am_Error_e changeMainSinkSoundPropertyDB(const am_MainSoundProperty_s& soundProperty, const am_sinkID_t sinkID) =0;
-	/**
-	 * changes the mainsourcesoundproperty of a sink
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if source
-	 * was not found
-	 */
-	virtual am_Error_e changeMainSourceSoundPropertyDB(const am_MainSoundProperty_s& soundProperty, const am_sourceID_t sourceID) =0;
-	/**
-	 * changes the availablility of a source
-	 * @return E_OK on success, E_DATABASE_ERROR  on error, E_NON_EXISTENT if source
-	 * was not found
-	 */
-	virtual am_Error_e changeSourceAvailabilityDB(const am_Availability_s& availability, const am_sourceID_t sourceID) =0;
-	/**
-	 * changes a systemProperty
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if property
-	 * was not found
-	 */
-	virtual am_Error_e changeSystemPropertyDB(const am_SystemProperty_s& property) =0;
-	/**
-	 * removes a mainconnection from the DB
-	 * @return E_OK on success, E_NON_EXISTENT if main connection was not found,
-	 * E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e removeMainConnectionDB(const am_mainConnectionID_t mainConnectionID) =0;
-	/**
-	 * removes a sink from the DB
-	 * @return E_OK on success, E_NON_EXISTENT if sink was not found, E_DATABASE_ERROR
-	 * if the database had an error
-	 */
-	virtual am_Error_e removeSinkDB(const am_sinkID_t sinkID) =0;
-	/**
-	 * removes a source from the DB
-	 * @return E_OK on success, E_NON_EXISTENT if source was not found,
-	 * E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e removeSourceDB(const am_sourceID_t sourceID) =0;
-	/**
-	 * removes a gateway from the DB
-	 * @return E_OK on success, E_NON_EXISTENT if gateway was not found,
-	 * E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e removeGatewayDB(const am_gatewayID_t gatewayID) =0;
-	/**
-	 * removes a converter from the DB
-	 * @return E_OK on success, E_NON_EXISTENT if gateway was not found,
-	 * E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e removeConverterDB(const am_converterID_t converterID) =0;
-	/**
-	 * removes a crossfader from the DB
-	 * @return E_OK on success, E_NON_EXISTENT if crossfader was not found,
-	 * E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e removeCrossfaderDB(const am_crossfaderID_t crossfaderID) =0;
-	/**
-	 * removes a domain from the DB
-	 * @return E_OK on success, E_NON_EXISTENT if domain was not found,
-	 * E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e removeDomainDB(const am_domainID_t domainID) =0;
-	/**
-	 * removes a domain from the DB
-	 * @return E_OK on success, E_NON_EXISTENT if domain was not found,
-	 * E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e removeSinkClassDB(const am_sinkClass_t sinkClassID) =0;
-	/**
-	 * removes a domain from the DB
-	 * @return E_OK on success, E_NON_EXISTENT if domain was not found,
-	 * E_DATABASE_ERROR if the database had an error
-	 */
-	virtual am_Error_e removeSourceClassDB(const am_sourceClass_t sourceClassID) =0;
-	/**
-	 * returns the ClassInformation of a source
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if source
-	 * was not found
-	 */
-	virtual am_Error_e getSourceClassInfoDB(const am_sourceID_t sourceID, am_SourceClass_s& classInfo) const =0;
-	/**
-	 * returns the ClassInformation of a sink
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
-	 * not found
-	 */
-	virtual am_Error_e getSinkClassInfoDB(const am_sinkID_t sinkID, am_SinkClass_s& sinkClass) const =0;
-	/**
-	 * returns the sinkData of a sink
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
-	 * not found
-	 */
-	virtual am_Error_e getSinkInfoDB(const am_sinkID_t sinkID, am_Sink_s& sinkData) const =0;
-	/**
-	 * returns the sourcekData of a source
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
-	 * not found
-	 */
-	virtual am_Error_e getSourceInfoDB(const am_sourceID_t sourceID, am_Source_s& sourceData) const =0;
-	/**
-	 * return source and sink of a converter
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if gateway
-	 * was not found
-	 */
-	virtual am_Error_e getConverterInfoDB(const am_converterID_t converterID, am_Converter_s& converterData) const =0;
-	/**
-	 * return source and sink of a gateway
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if gateway
-	 * was not found
-	 */
-	virtual am_Error_e getGatewayInfoDB(const am_gatewayID_t gatewayID, am_Gateway_s& gatewayData) const =0;
-	/**
-	 * returns sources and the sink of a crossfader
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if
-	 * crossfader was not found
-	 */
-	virtual am_Error_e getCrossfaderInfoDB(const am_crossfaderID_t crossfaderID, am_Crossfader_s& crossfaderData) const =0;
-	/**
-	 * returns sources and the sink of a crossfader
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if
-	 * crossfader was not found
-	 */
-	virtual am_Error_e getMainConnectionInfoDB(const am_mainConnectionID_t mainConnectionID, am_MainConnection_s& mainConnectionData) const =0;
-	/**
-	 * returns all sinks of a domain
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
-	 * was not found
-	 */
-	virtual am_Error_e getListSinksOfDomain(const am_domainID_t domainID, std::vector<am_sinkID_t>& listSinkID) const =0;
-	/**
-	 * returns all source of a domain
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
-	 * was not found
-	 */
-	virtual am_Error_e getListSourcesOfDomain(const am_domainID_t domainID, std::vector<am_sourceID_t>& listSourceID) const =0;
-	/**
-	 * returns all crossfaders of a domain
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
-	 * was not found
-	 */
-	virtual am_Error_e getListCrossfadersOfDomain(const am_domainID_t domainID, std::vector<am_crossfaderID_t>& listCrossfadersID) const =0;
-	/**
-	 * returns all converters of a domain
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
-	 * was not found
-	 */
-	virtual am_Error_e getListConvertersOfDomain(const am_domainID_t domainID, std::vector<am_converterID_t>& listConverterID) const =0;
-	/**
-	 * returns all gateways of a domain
-	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
-	 * was not found
-	 */
-	virtual am_Error_e getListGatewaysOfDomain(const am_domainID_t domainID, std::vector<am_gatewayID_t>& listGatewaysID) const =0;
-	/**
-	 * returns a complete list of all MainConnections
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListMainConnections(std::vector<am_MainConnection_s>& listMainConnections) const =0;
-	/**
-	 * returns a complete list of all domains
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListDomains(std::vector<am_Domain_s>& listDomains) const =0;
-	/**
-	 * returns a complete list of all Connections
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListConnections(std::vector<am_Connection_s>& listConnections) const =0;
-	/**
-	 * returns a list of all sinks
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListSinks(std::vector<am_Sink_s>& listSinks) const =0;
-	/**
-	 * returns a list of all sources
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListSources(std::vector<am_Source_s>& listSources) const =0;
-	/**
-	 * returns a list of all source classes
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListSourceClasses(std::vector<am_SourceClass_s>& listSourceClasses) const =0;
-	/**
-	 * returns a list of all handles
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListHandles(std::vector<am_Handle_s>& listHandles) const =0;
-	/**
-	 * returns a list of all crossfaders
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListCrossfaders(std::vector<am_Crossfader_s>& listCrossfaders) const =0;
-	/**
-	 * returns a list of  converters
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListConverters(std::vector<am_Converter_s>& listConverters) const =0;
-	/**
-	 * returns a list of  gateways
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListGateways(std::vector<am_Gateway_s>& listGateways) const =0;
-	/**
-	 * returns a list of all sink classes
-	 * @return E_OK on success, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e getListSinkClasses(std::vector<am_SinkClass_s>& listSinkClasses) const =0;
-	/**
-	 * returns the list of SystemProperties
-	 */
-	virtual am_Error_e getListSystemProperties(std::vector<am_SystemProperty_s>& listSystemProperties) const =0;
-	/**
-	 * sets the command interface to ready. Will send setCommandReady to each of the
-	 * plugins. The corresponding answer is confirmCommandReady. 
-	 */
-	virtual void setCommandReady() =0;
-	/**
-	 * sets the command interface into the rundown state. Will send setCommandRundown
-	 * to each of the plugins. The corresponding answer is confirmCommandRundown. 
-	 */
-	virtual void setCommandRundown() =0;
-	/**
-	 * sets the routinginterface to  ready. Will send the command  setRoutingReady to
-	 * each of the plugins. The related answer is confirmRoutingReady.
-	 */
-	virtual void setRoutingReady() =0;
-	/**
-	 * sets the routinginterface to the rundown state. Will send the command
-	 * setRoutingRundown to each of the plugins. The related answer is
-	 * confirmRoutingRundown.
-	 */
-	virtual void setRoutingRundown() =0;
-	/**
-	 * acknowledges the setControllerReady call.
-	 */
-	virtual void confirmControllerReady(const am_Error_e error) =0;
-	/**
-	 * Acknowledges the setControllerRundown call.
-	 */
-	virtual void confirmControllerRundown(const am_Error_e error) =0;
-	/**
-	 * This function returns the pointer to the socketHandler. This can be used to
-	 * integrate socket-based activites like communication with the mainloop of the
-	 * AudioManager.
-	 * returns E_OK if pointer is valid, E_UNKNOWN in case AudioManager was compiled
-	 * without socketHandler support,
-	 */
-	virtual am_Error_e getSocketHandler(CAmSocketHandler*& socketHandler) =0;
-	/**
-	 * Change the data of the source.
-	 */
-	virtual am_Error_e changeSourceDB(const am_sourceID_t sourceID, const am_sourceClass_t sourceClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
-	/**
-	 * Change the data of the sink.
-	 */
-	virtual am_Error_e changeSinkDB(const am_sinkID_t sinkID, const am_sinkClass_t sinkClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
-	/**
-	 * changes converter Data
-	 */
-	virtual am_Error_e changeConverterDB(const am_converterID_t converterID, const std::vector<am_CustomConnectionFormat_t>& listSourceConnectionFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkConnectionFormats, const std::vector<bool>& convertionMatrix) =0;
-	/**
-	 * changes Gateway Data
-	 */
-	virtual am_Error_e changeGatewayDB(const am_gatewayID_t gatewayID, const std::vector<am_CustomConnectionFormat_t>& listSourceConnectionFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkConnectionFormats, const std::vector<bool>& convertionMatrix) =0;
-	/**
-	 * with this function, setting of multiple volumes at a time is done. The behavior
-	 * of the volume set is depended on the given ramp and time information.
-	 * This function is not only used to ramp volume, but also to mute and direct set
-	 * the level. Exact behavior is depended on the selected mute ramps.
-	 * @return E_OK on success, E_NO_CHANGE if the volume is already on the desired
-	 * value, E_OUT_OF_RANGE is the volume is out of range, E_UNKNOWN on every other
-	 * error.
-	 */
-	virtual am_Error_e setVolumes(am_Handle_s& handle, const std::vector<am_Volumes_s>& listVolumes) =0;
-	/**
-	 * set a sink notification configuration
-	 */
-	virtual am_Error_e setSinkNotificationConfiguration(am_Handle_s& handle, const am_sinkID_t sinkID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
-	/**
-	 * set a source notification configuration
-	 */
-	virtual am_Error_e setSourceNotificationConfiguration(am_Handle_s& handle, const am_sourceID_t sourceID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
-	/**
-	 * Sends out the main notificiation of a sink
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual void sendMainSinkNotificationPayload(const am_sinkID_t sinkID, const am_NotificationPayload_s& notificationPayload) =0;
-	/**
-	 * Sends out the main notificiation of a source
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual void sendMainSourceNotificationPayload(const am_sourceID_t sourceID, const am_NotificationPayload_s& notificationPayload) =0;
-	/**
-	 * change the mainNotificationConfiguration of a sink
-	 * @return E_OK when successful, E_DATABASE on error
-	 */
-	virtual am_Error_e changeMainSinkNotificationConfigurationDB(const am_sinkID_t sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
-	/**
-	 * change the mainNotificationConfiguration of a source
-	 * @return E_OK when successful, E_DATABASE on error
-	 */
-	virtual am_Error_e changeMainSourceNotificationConfigurationDB(const am_sourceID_t sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
-	/**
-	 * Retrieves the Restart Reason Property
-	 * @return E_OK on success E_UNKNOWN if property could not be retrieved.
-	 */
-	virtual am_Error_e getRestartReasonPropertyNSM(NsmRestartReason_e& restartReason) =0;
-	/**
-	 * Retrieves the shutdown reason property
-	 * @return E_OK on success E_UNKNOWN if property could not be retrieved.
-	 */
-	virtual am_Error_e getShutdownReasonPropertyNSM(NsmShutdownReason_e& ShutdownReason) =0;
-	/**
-	 * Retrieves the running reason
-	 * @return E_OK on success E_UNKNOWN if property could not be retrieved.
-	 */
-	virtual am_Error_e getRunningReasonPropertyNSM(NsmRunningReason_e& nsmRunningReason) =0;
-	/**
-	 * @return NsmErrorStatus_Ok in case of success
-	 */
-	virtual NsmErrorStatus_e getNodeStateNSM(NsmNodeState_e& nsmNodeState) =0;
-	/**
-	 * Retrieves the current session state
-	 * @return NsmErrorStatus_Ok on success E_UNKNOWN if property could not be
-	 * retrieved.
-	 */
-	virtual NsmErrorStatus_e getSessionStateNSM(const std::string& sessionName, const NsmSeat_e seatID, NsmSessionState_e& sessionState) =0;
-	/**
-	 * Retrieves the current applicationmode
-	 * @return NsmErrorStatus_Ok on success E_UNKNOWN if property could not be
-	 * retrieved.
-	 */
-	virtual NsmErrorStatus_e getApplicationModeNSM(NsmApplicationMode_e& applicationMode) =0;
-	/**
-	 * Registers the AudioManager as shutdown client
-	 * @return NsmErrorStatus_Ok on success
-	 * The interface for the client will be provided by the AudioManagerDeamon,
-	 * therefore is no need to mention it here.
-	 */
-	virtual NsmErrorStatus_e registerShutdownClientNSM(const uint32_t shutdownMode, const uint32_t timeoutMs) =0;
-	/**
-	 * unregisters the AudioManager as shutdown client
-	 * @return NsmErrorStatus_Ok on success
-	 */
-	virtual NsmErrorStatus_e unRegisterShutdownClientNSM(const uint32_t shutdownMode) =0;
-	/**
-	 * @return E_OK on success, E_UNKOWN if interface could not be reached
-	 */
-	virtual am_Error_e getInterfaceVersionNSM(uint32_t& version) =0;
-	/**
-	 * Sends out the lifecyclerequest complete to the NSM
-	 * @return NsmErrorStatus_Ok in case of success
-	 */
-	virtual NsmErrorStatus_e sendLifecycleRequestCompleteNSM(const uint32_t RequestId, const NsmErrorStatus_e status) =0;
-	/**
-	 * This function retrieves a list of all sink mainsoundproperties with its values
-	 * @return E_OK when successful, E_DATABASE on error
-	 */
-	virtual am_Error_e getListMainSinkSoundProperties(const am_sinkID_t sinkID, std::vector<am_MainSoundProperty_s>& listSoundproperties) const =0;
-	/**
-	 * This function retrieves a list of all source mainsoundproperties with its
-	 * values
-	 * @return E_OK when successful, E_DATABASE on error
-	 */
-	virtual am_Error_e getListMainSourceSoundProperties(const am_sourceID_t sourceID, std::vector<am_MainSoundProperty_s>& listSoundproperties) const =0;
-	/**
-	 * This function retrieves a list of all sink soundproperties with its values
-	 * @return E_OK when successful, E_DATABASE on error
-	 */
-	virtual am_Error_e getListSinkSoundProperties(const am_sinkID_t sinkID, std::vector<am_SoundProperty_s>& listSoundproperties) const =0;
-	/**
-	 * This function retrieves a list of all sink soundproperties with its values
-	 * @return E_OK when successful, E_DATABASE on error
-	 */
-	virtual am_Error_e getListSourceSoundProperties(const am_sourceID_t sourceID, std::vector<am_SoundProperty_s>& listSoundproperties) const =0;
-	/**
-	 * This function retrieves the value of a sink Mainsoundproperty.
-	 * @return E_OK when successful, E_DATABASE on error
-	 */
-	virtual am_Error_e getMainSinkSoundPropertyValue(const am_sinkID_t sinkID, const am_CustomMainSoundPropertyType_t propertyType, int16_t& value) const =0;
-	/**
-	 * This function retrieves the value of a sink soundproperty.
-	 * @return E_OK when successful, E_DATABASE on error
-	 */
-	virtual am_Error_e getSinkSoundPropertyValue(const am_sinkID_t sinkID, const am_CustomSoundPropertyType_t propertyType, int16_t& value) const =0;
-	/**
-	 * This function retrieves the value of a source Mainsoundproperty.
-	 * @return E_OK when successful, E_DATABASE on error
-	 */
-	virtual am_Error_e getMainSourceSoundPropertyValue(const am_sourceID_t sourceID, const am_CustomMainSoundPropertyType_t propertyType, int16_t& value) const =0;
-	/**
-	 * This function retrieves the value of a source soundproperty.
-	 * @return E_OK when successful, E_DATABASE on error
-	 */
-	virtual am_Error_e getSourceSoundPropertyValue(const am_sourceID_t sourceID, const am_CustomSoundPropertyType_t propertyType, int16_t& value) const =0;
-
-};
-
-/**
- * This interface is presented by the AudioManager controller.
- * All the hooks represent system events that need to be handled. The callback
- * functions are used to handle for example answers to function calls on the
- * AudioManagerCoreInterface.
- * There are two rules that have to be kept in mind when implementing against this
- * interface:\n
- * \warning
- * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
- * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
- * CALL THAT EXPECTS A RETURN VALUE.\n
- * \details
- * Violation these rules may lead to unexpected behavior! Nevertheless you can
- * implement thread safe by using the deferred-call pattern described on the wiki
- * which also helps to implement calls that are forbidden.\n
- * For more information, please check CAmSerializer
- */
-class IAmControlSend
-{
-
-public:
-	IAmControlSend() {
-
-	}
-
-	virtual ~IAmControlSend() {
-
-	}
-
-	/**
-	 * This function returns the version of the interface
-	 * returns E_OK, E_UNKOWN if version is unknown.
-	 */
-	virtual void getInterfaceVersion(std::string& version) const =0;
-	/**
-	 * Starts up the controller.
-	 */
-	virtual am_Error_e startupController(IAmControlReceive* controlreceiveinterface) =0;
-	/**
-	 * this message is used tell the controller that it should get ready. This message
-	 * must be acknowledged via confirmControllerReady.
-	 */
-	virtual void setControllerReady() =0;
-	/**
-	 * This message tells the controller that he should prepare everything for the
-	 * power to be switched off. This message must be acknowledged via
-	 * confirmControllerRundown.
-	 * The method will give the signal as integer that was responsible for calling the
-	 * setControllerRundown.
-	 * This function is called from the signal handler, either direct (when the
-	 * program is killed) or from within the mainloop (if the program is terminated).
-	 */
-	virtual void setControllerRundown(const int16_t signal) =0;
-	/**
-	 * is called when a connection request comes in via the command interface
-	 * @return E_OK on success, E_NOT_POSSIBLE on error, E_ALREADY_EXISTENT if already
-	 * exists
-	 */
-	virtual am_Error_e hookUserConnectionRequest(const am_sourceID_t sourceID, const am_sinkID_t sinkID, am_mainConnectionID_t& mainConnectionID) =0;
-	/**
-	 * is called when a disconnection request comes in via the command interface
-	 * @return E_OK on success, E_NOT_POSSIBLE on error, E_NON_EXISTENT if connection
-	 * does not exists
-	 */
-	virtual am_Error_e hookUserDisconnectionRequest(const am_mainConnectionID_t connectionID) =0;
-	/**
-	 * sets a user MainSinkSoundProperty
-	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
-	 */
-	virtual am_Error_e hookUserSetMainSinkSoundProperty(const am_sinkID_t sinkID, const am_MainSoundProperty_s& soundProperty) =0;
-	/**
-	 * sets a user MainSourceSoundProperty
-	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
-	 */
-	virtual am_Error_e hookUserSetMainSourceSoundProperty(const am_sourceID_t sourceID, const am_MainSoundProperty_s& soundProperty) =0;
-	/**
-	 * sets a user SystemProperty
-	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
-	 */
-	virtual am_Error_e hookUserSetSystemProperty(const am_SystemProperty_s& property) =0;
-	/**
-	 * sets a user volume
-	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
-	 */
-	virtual am_Error_e hookUserVolumeChange(const am_sinkID_t SinkID, const am_mainVolume_t newVolume) =0;
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
+	 * not found
+	 */
+	virtual am_Error_e changeSinkAvailabilityDB(const am_Availability_s& availability, const am_sinkID_t sinkID) =0;
+	/**
+	 * changes the domainstate of a domain
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
+	 * was not found
+	 */
+	virtual am_Error_e changDomainStateDB(const am_DomainState_e domainState, const am_domainID_t domainID) =0;
+	/**
+	 * changes the mute state of a sink
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
+	 * not found 
+	 */
+	virtual am_Error_e changeSinkMuteStateDB(const am_MuteState_e muteState, const am_sinkID_t sinkID) =0;
+	/**
+	 * changes the mainsinksoundproperty of a sink
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
+	 * not found
+	 */
+	virtual am_Error_e changeMainSinkSoundPropertyDB(const am_MainSoundProperty_s& soundProperty, const am_sinkID_t sinkID) =0;
+	/**
+	 * changes the mainsourcesoundproperty of a sink
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if source
+	 * was not found
+	 */
+	virtual am_Error_e changeMainSourceSoundPropertyDB(const am_MainSoundProperty_s& soundProperty, const am_sourceID_t sourceID) =0;
+	/**
+	 * changes the availablility of a source
+	 * @return E_OK on success, E_DATABASE_ERROR  on error, E_NON_EXISTENT if source
+	 * was not found
+	 */
+	virtual am_Error_e changeSourceAvailabilityDB(const am_Availability_s& availability, const am_sourceID_t sourceID) =0;
+	/**
+	 * changes a systemProperty
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if property
+	 * was not found
+	 */
+	virtual am_Error_e changeSystemPropertyDB(const am_SystemProperty_s& property) =0;
+	/**
+	 * removes a mainconnection from the DB
+	 * @return E_OK on success, E_NON_EXISTENT if main connection was not found,
+	 * E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e removeMainConnectionDB(const am_mainConnectionID_t mainConnectionID) =0;
+	/**
+	 * removes a sink from the DB
+	 * @return E_OK on success, E_NON_EXISTENT if sink was not found, E_DATABASE_ERROR
+	 * if the database had an error
+	 */
+	virtual am_Error_e removeSinkDB(const am_sinkID_t sinkID) =0;
+	/**
+	 * removes a source from the DB
+	 * @return E_OK on success, E_NON_EXISTENT if source was not found,
+	 * E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e removeSourceDB(const am_sourceID_t sourceID) =0;
+	/**
+	 * removes a gateway from the DB
+	 * @return E_OK on success, E_NON_EXISTENT if gateway was not found,
+	 * E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e removeGatewayDB(const am_gatewayID_t gatewayID) =0;
+	/**
+	 * removes a converter from the DB
+	 * @return E_OK on success, E_NON_EXISTENT if gateway was not found,
+	 * E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e removeConverterDB(const am_converterID_t converterID) =0;
+	/**
+	 * removes a crossfader from the DB
+	 * @return E_OK on success, E_NON_EXISTENT if crossfader was not found,
+	 * E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e removeCrossfaderDB(const am_crossfaderID_t crossfaderID) =0;
+	/**
+	 * removes a domain from the DB
+	 * @return E_OK on success, E_NON_EXISTENT if domain was not found,
+	 * E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e removeDomainDB(const am_domainID_t domainID) =0;
+	/**
+	 * removes a domain from the DB
+	 * @return E_OK on success, E_NON_EXISTENT if domain was not found,
+	 * E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e removeSinkClassDB(const am_sinkClass_t sinkClassID) =0;
+	/**
+	 * removes a domain from the DB
+	 * @return E_OK on success, E_NON_EXISTENT if domain was not found,
+	 * E_DATABASE_ERROR if the database had an error
+	 */
+	virtual am_Error_e removeSourceClassDB(const am_sourceClass_t sourceClassID) =0;
+	/**
+	 * returns the ClassInformation of a source
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if source
+	 * was not found
+	 */
+	virtual am_Error_e getSourceClassInfoDB(const am_sourceID_t sourceID, am_SourceClass_s& classInfo) const =0;
+	/**
+	 * returns the ClassInformation of a sink
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
+	 * not found
+	 */
+	virtual am_Error_e getSinkClassInfoDB(const am_sinkID_t sinkID, am_SinkClass_s& sinkClass) const =0;
+	/**
+	 * returns the sinkData of a sink
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
+	 * not found
+	 */
+	virtual am_Error_e getSinkInfoDB(const am_sinkID_t sinkID, am_Sink_s& sinkData) const =0;
+	/**
+	 * returns the sourcekData of a source
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if sink was
+	 * not found
+	 */
+	virtual am_Error_e getSourceInfoDB(const am_sourceID_t sourceID, am_Source_s& sourceData) const =0;
+	/**
+	 * return source and sink of a converter
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if gateway
+	 * was not found
+	 */
+	virtual am_Error_e getConverterInfoDB(const am_converterID_t converterID, am_Converter_s& converterData) const =0;
+	/**
+	 * return source and sink of a gateway
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if gateway
+	 * was not found
+	 */
+	virtual am_Error_e getGatewayInfoDB(const am_gatewayID_t gatewayID, am_Gateway_s& gatewayData) const =0;
+	/**
+	 * returns sources and the sink of a crossfader
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if
+	 * crossfader was not found
+	 */
+	virtual am_Error_e getCrossfaderInfoDB(const am_crossfaderID_t crossfaderID, am_Crossfader_s& crossfaderData) const =0;
+	/**
+	 * returns sources and the sink of a crossfader
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if
+	 * crossfader was not found
+	 */
+	virtual am_Error_e getMainConnectionInfoDB(const am_mainConnectionID_t mainConnectionID, am_MainConnection_s& mainConnectionData) const =0;
+	/**
+	 * returns all sinks of a domain
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
+	 * was not found
+	 */
+	virtual am_Error_e getListSinksOfDomain(const am_domainID_t domainID, std::vector<am_sinkID_t>& listSinkID) const =0;
+	/**
+	 * returns all source of a domain
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
+	 * was not found
+	 */
+	virtual am_Error_e getListSourcesOfDomain(const am_domainID_t domainID, std::vector<am_sourceID_t>& listSourceID) const =0;
+	/**
+	 * returns all crossfaders of a domain
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
+	 * was not found
+	 */
+	virtual am_Error_e getListCrossfadersOfDomain(const am_domainID_t domainID, std::vector<am_crossfaderID_t>& listCrossfadersID) const =0;
+	/**
+	 * returns all converters of a domain
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
+	 * was not found
+	 */
+	virtual am_Error_e getListConvertersOfDomain(const am_domainID_t domainID, std::vector<am_converterID_t>& listConverterID) const =0;
+	/**
+	 * returns all gateways of a domain
+	 * @return E_OK on success, E_DATABASE_ERROR on error, E_NON_EXISTENT if domain
+	 * was not found
+	 */
+	virtual am_Error_e getListGatewaysOfDomain(const am_domainID_t domainID, std::vector<am_gatewayID_t>& listGatewaysID) const =0;
+	/**
+	 * returns a complete list of all MainConnections
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListMainConnections(std::vector<am_MainConnection_s>& listMainConnections) const =0;
+	/**
+	 * returns a complete list of all domains
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListDomains(std::vector<am_Domain_s>& listDomains) const =0;
+	/**
+	 * returns a complete list of all Connections
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListConnections(std::vector<am_Connection_s>& listConnections) const =0;
+	/**
+	 * returns a list of all sinks
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListSinks(std::vector<am_Sink_s>& listSinks) const =0;
+	/**
+	 * returns a list of all sources
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListSources(std::vector<am_Source_s>& listSources) const =0;
+	/**
+	 * returns a list of all source classes
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListSourceClasses(std::vector<am_SourceClass_s>& listSourceClasses) const =0;
+	/**
+	 * returns a list of all handles
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListHandles(std::vector<am_Handle_s>& listHandles) const =0;
+	/**
+	 * returns a list of all crossfaders
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListCrossfaders(std::vector<am_Crossfader_s>& listCrossfaders) const =0;
+	/**
+	 * returns a list of  converters
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListConverters(std::vector<am_Converter_s>& listConverters) const =0;
+	/**
+	 * returns a list of  gateways
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListGateways(std::vector<am_Gateway_s>& listGateways) const =0;
+	/**
+	 * returns a list of all sink classes
+	 * @return E_OK on success, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e getListSinkClasses(std::vector<am_SinkClass_s>& listSinkClasses) const =0;
+	/**
+	 * returns the list of SystemProperties
+	 */
+	virtual am_Error_e getListSystemProperties(std::vector<am_SystemProperty_s>& listSystemProperties) const =0;
+	/**
+	 * sets the command interface to ready. Will send setCommandReady to each of the
+	 * plugins. The corresponding answer is confirmCommandReady. 
+	 */
+	virtual void setCommandReady() =0;
+	/**
+	 * sets the command interface into the rundown state. Will send setCommandRundown
+	 * to each of the plugins. The corresponding answer is confirmCommandRundown. 
+	 */
+	virtual void setCommandRundown() =0;
+	/**
+	 * sets the routinginterface to  ready. Will send the command  setRoutingReady to
+	 * each of the plugins. The related answer is confirmRoutingReady.
+	 */
+	virtual void setRoutingReady() =0;
+	/**
+	 * sets the routinginterface to the rundown state. Will send the command
+	 * setRoutingRundown to each of the plugins. The related answer is
+	 * confirmRoutingRundown.
+	 */
+	virtual void setRoutingRundown() =0;
+	/**
+	 * acknowledges the setControllerReady call.
+	 */
+	virtual void confirmControllerReady(const am_Error_e error) =0;
+	/**
+	 * Acknowledges the setControllerRundown call.
+	 */
+	virtual void confirmControllerRundown(const am_Error_e error) =0;
+	/**
+	 * This function returns the pointer to the socketHandler. This can be used to
+	 * integrate socket-based activites like communication with the mainloop of the
+	 * AudioManager.
+	 * returns E_OK if pointer is valid, E_UNKNOWN in case AudioManager was compiled
+	 * without socketHandler support,
+	 */
+	virtual am_Error_e getSocketHandler(CAmSocketHandler*& socketHandler) =0;
+	/**
+	 * Change the data of the source.
+	 */
+	virtual am_Error_e changeSourceDB(const am_sourceID_t sourceID, const am_sourceClass_t sourceClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
+	/**
+	 * Change the data of the sink.
+	 */
+	virtual am_Error_e changeSinkDB(const am_sinkID_t sinkID, const am_sinkClass_t sinkClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
+	/**
+	 * changes converter Data
+	 */
+	virtual am_Error_e changeConverterDB(const am_converterID_t converterID, const std::vector<am_CustomConnectionFormat_t>& listSourceConnectionFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkConnectionFormats, const std::vector<bool>& convertionMatrix) =0;
+	/**
+	 * changes Gateway Data
+	 */
+	virtual am_Error_e changeGatewayDB(const am_gatewayID_t gatewayID, const std::vector<am_CustomConnectionFormat_t>& listSourceConnectionFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkConnectionFormats, const std::vector<bool>& convertionMatrix) =0;
+	/**
+	 * with this function, setting of multiple volumes at a time is done. The behavior
+	 * of the volume set is depended on the given ramp and time information.
+	 * This function is not only used to ramp volume, but also to mute and direct set
+	 * the level. Exact behavior is depended on the selected mute ramps.
+	 * @return E_OK on success, E_NO_CHANGE if the volume is already on the desired
+	 * value, E_OUT_OF_RANGE is the volume is out of range, E_UNKNOWN on every other
+	 * error.
+	 */
+	virtual am_Error_e setVolumes(am_Handle_s& handle, const std::vector<am_Volumes_s>& listVolumes) =0;
+	/**
+	 * set a sink notification configuration
+	 */
+	virtual am_Error_e setSinkNotificationConfiguration(am_Handle_s& handle, const am_sinkID_t sinkID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
+	/**
+	 * set a source notification configuration
+	 */
+	virtual am_Error_e setSourceNotificationConfiguration(am_Handle_s& handle, const am_sourceID_t sourceID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
+	/**
+	 * Sends out the main notificiation of a sink
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual void sendMainSinkNotificationPayload(const am_sinkID_t sinkID, const am_NotificationPayload_s& notificationPayload) =0;
+	/**
+	 * Sends out the main notificiation of a source
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual void sendMainSourceNotificationPayload(const am_sourceID_t sourceID, const am_NotificationPayload_s& notificationPayload) =0;
+	/**
+	 * change the mainNotificationConfiguration of a sink
+	 * @return E_OK when successful, E_DATABASE on error
+	 */
+	virtual am_Error_e changeMainSinkNotificationConfigurationDB(const am_sinkID_t sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
+	/**
+	 * change the mainNotificationConfiguration of a source
+	 * @return E_OK when successful, E_DATABASE on error
+	 */
+	virtual am_Error_e changeMainSourceNotificationConfigurationDB(const am_sourceID_t sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
+	/**
+	 * Retrieves the Restart Reason Property
+	 * @return E_OK on success E_UNKNOWN if property could not be retrieved.
+	 */
+	virtual am_Error_e getRestartReasonPropertyNSM(NsmRestartReason_e& restartReason) =0;
+	/**
+	 * Retrieves the shutdown reason property
+	 * @return E_OK on success E_UNKNOWN if property could not be retrieved.
+	 */
+	virtual am_Error_e getShutdownReasonPropertyNSM(NsmShutdownReason_e& ShutdownReason) =0;
+	/**
+	 * Retrieves the running reason
+	 * @return E_OK on success E_UNKNOWN if property could not be retrieved.
+	 */
+	virtual am_Error_e getRunningReasonPropertyNSM(NsmRunningReason_e& nsmRunningReason) =0;
+	/**
+	 * @return NsmErrorStatus_Ok in case of success
+	 */
+	virtual NsmErrorStatus_e getNodeStateNSM(NsmNodeState_e& nsmNodeState) =0;
+	/**
+	 * Retrieves the current session state
+	 * @return NsmErrorStatus_Ok on success E_UNKNOWN if property could not be
+	 * retrieved.
+	 */
+	virtual NsmErrorStatus_e getSessionStateNSM(const std::string& sessionName, const NsmSeat_e seatID, NsmSessionState_e& sessionState) =0;
+	/**
+	 * Retrieves the current applicationmode
+	 * @return NsmErrorStatus_Ok on success E_UNKNOWN if property could not be
+	 * retrieved.
+	 */
+	virtual NsmErrorStatus_e getApplicationModeNSM(NsmApplicationMode_e& applicationMode) =0;
+	/**
+	 * Registers the AudioManager as shutdown client
+	 * @return NsmErrorStatus_Ok on success
+	 * The interface for the client will be provided by the AudioManagerDeamon,
+	 * therefore is no need to mention it here.
+	 */
+	virtual NsmErrorStatus_e registerShutdownClientNSM(const uint32_t shutdownMode, const uint32_t timeoutMs) =0;
+	/**
+	 * unregisters the AudioManager as shutdown client
+	 * @return NsmErrorStatus_Ok on success
+	 */
+	virtual NsmErrorStatus_e unRegisterShutdownClientNSM(const uint32_t shutdownMode) =0;
+	/**
+	 * @return E_OK on success, E_UNKOWN if interface could not be reached
+	 */
+	virtual am_Error_e getInterfaceVersionNSM(uint32_t& version) =0;
+	/**
+	 * Sends out the lifecyclerequest complete to the NSM
+	 * @return NsmErrorStatus_Ok in case of success
+	 */
+	virtual NsmErrorStatus_e sendLifecycleRequestCompleteNSM(const uint32_t RequestId, const NsmErrorStatus_e status) =0;
+	/**
+	 * This function retrieves a list of all sink mainsoundproperties with its values
+	 * @return E_OK when successful, E_DATABASE on error
+	 */
+	virtual am_Error_e getListMainSinkSoundProperties(const am_sinkID_t sinkID, std::vector<am_MainSoundProperty_s>& listSoundproperties) const =0;
+	/**
+	 * This function retrieves a list of all source mainsoundproperties with its
+	 * values
+	 * @return E_OK when successful, E_DATABASE on error
+	 */
+	virtual am_Error_e getListMainSourceSoundProperties(const am_sourceID_t sourceID, std::vector<am_MainSoundProperty_s>& listSoundproperties) const =0;
+	/**
+	 * This function retrieves a list of all sink soundproperties with its values
+	 * @return E_OK when successful, E_DATABASE on error
+	 */
+	virtual am_Error_e getListSinkSoundProperties(const am_sinkID_t sinkID, std::vector<am_SoundProperty_s>& listSoundproperties) const =0;
+	/**
+	 * This function retrieves a list of all sink soundproperties with its values
+	 * @return E_OK when successful, E_DATABASE on error
+	 */
+	virtual am_Error_e getListSourceSoundProperties(const am_sourceID_t sourceID, std::vector<am_SoundProperty_s>& listSoundproperties) const =0;
+	/**
+	 * This function retrieves the value of a sink Mainsoundproperty.
+	 * @return E_OK when successful, E_DATABASE on error
+	 */
+	virtual am_Error_e getMainSinkSoundPropertyValue(const am_sinkID_t sinkID, const am_CustomMainSoundPropertyType_t propertyType, int16_t& value) const =0;
+	/**
+	 * This function retrieves the value of a sink soundproperty.
+	 * @return E_OK when successful, E_DATABASE on error
+	 */
+	virtual am_Error_e getSinkSoundPropertyValue(const am_sinkID_t sinkID, const am_CustomSoundPropertyType_t propertyType, int16_t& value) const =0;
+	/**
+	 * This function retrieves the value of a source Mainsoundproperty.
+	 * @return E_OK when successful, E_DATABASE on error
+	 */
+	virtual am_Error_e getMainSourceSoundPropertyValue(const am_sourceID_t sourceID, const am_CustomMainSoundPropertyType_t propertyType, int16_t& value) const =0;
+	/**
+	 * This function retrieves the value of a source soundproperty.
+	 * @return E_OK when successful, E_DATABASE on error
+	 */
+	virtual am_Error_e getSourceSoundPropertyValue(const am_sourceID_t sourceID, const am_CustomSoundPropertyType_t propertyType, int16_t& value) const =0;
+
+};
+
+/**
+ * This interface is presented by the AudioManager controller.
+ * All the hooks represent system events that need to be handled. The callback
+ * functions are used to handle for example answers to function calls on the
+ * AudioManagerCoreInterface.
+ * There are two rules that have to be kept in mind when implementing against this
+ * interface:\n
+ * \warning
+ * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
+ * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
+ * CALL THAT EXPECTS A RETURN VALUE.\n
+ * \details
+ * Violation these rules may lead to unexpected behavior! Nevertheless you can
+ * implement thread safe by using the deferred-call pattern described on the wiki
+ * which also helps to implement calls that are forbidden.\n
+ * For more information, please check CAmSerializer
+ */
+class IAmControlSend
+{
+
+public:
+	IAmControlSend() {
+
+	}
+
+	virtual ~IAmControlSend() {
+
+	}
+
+	/**
+	 * This function returns the version of the interface
+	 * returns E_OK, E_UNKOWN if version is unknown.
+	 */
+	virtual void getInterfaceVersion(std::string& version) const =0;
+	/**
+	 * Starts up the controller.
+	 */
+	virtual am_Error_e startupController(IAmControlReceive* controlreceiveinterface) =0;
+	/**
+	 * this message is used tell the controller that it should get ready. This message
+	 * must be acknowledged via confirmControllerReady.
+	 */
+	virtual void setControllerReady() =0;
+	/**
+	 * This message tells the controller that he should prepare everything for the
+	 * power to be switched off. This message must be acknowledged via
+	 * confirmControllerRundown.
+	 * The method will give the signal as integer that was responsible for calling the
+	 * setControllerRundown.
+	 * This function is called from the signal handler, either direct (when the
+	 * program is killed) or from within the mainloop (if the program is terminated).
+	 */
+	virtual void setControllerRundown(const int16_t signal) =0;
+	/**
+	 * is called when a connection request comes in via the command interface
+	 * @return E_OK on success, E_NOT_POSSIBLE on error, E_ALREADY_EXISTENT if already
+	 * exists
+	 */
+	virtual am_Error_e hookUserConnectionRequest(const am_sourceID_t sourceID, const am_sinkID_t sinkID, am_mainConnectionID_t& mainConnectionID) =0;
+	/**
+	 * is called when a disconnection request comes in via the command interface
+	 * @return E_OK on success, E_NOT_POSSIBLE on error, E_NON_EXISTENT if connection
+	 * does not exists
+	 */
+	virtual am_Error_e hookUserDisconnectionRequest(const am_mainConnectionID_t connectionID) =0;
+	/**
+	 * sets a user MainSinkSoundProperty
+	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
+	 */
+	virtual am_Error_e hookUserSetMainSinkSoundProperty(const am_sinkID_t sinkID, const am_MainSoundProperty_s& soundProperty) =0;
+	/**
+	 * sets a user MainSourceSoundProperty
+	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
+	 */
+	virtual am_Error_e hookUserSetMainSourceSoundProperty(const am_sourceID_t sourceID, const am_MainSoundProperty_s& soundProperty) =0;
+	/**
+	 * sets a user SystemProperty
+	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
+	 */
+	virtual am_Error_e hookUserSetSystemProperty(const am_SystemProperty_s& property) =0;
+	/**
+	 * sets a user volume
+	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
+	 */
+	virtual am_Error_e hookUserVolumeChange(const am_sinkID_t SinkID, const am_mainVolume_t newVolume) =0;
 	/**
 	 * sets a user volume as increment
 	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
 	 */
 	virtual am_Error_e hookUserSourceVolumeChange(const am_sourceID_t SourceID, const am_mainVolume_t newVolume) =0;
-	/**
-	 * sets a user volume as increment
-	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
-	 */
-	virtual am_Error_e hookUserVolumeStep(const am_sinkID_t SinkID, const int16_t increment) =0;
-	/**
-	 * sets the mute state of a sink
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e hookUserSetSinkMuteState(const am_sinkID_t sinkID, const am_MuteState_e muteState) =0;
-	/**
-	 * is called when a routing adaptor registers its domain
-	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
-	 * exists
-	 */
-	virtual am_Error_e hookSystemRegisterDomain(const am_Domain_s& domainData, am_domainID_t& domainID) =0;
-	/**
-	 * is called when a routing adaptor wants to derigister a domain
-	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
-	 */
-	virtual am_Error_e hookSystemDeregisterDomain(const am_domainID_t domainID) =0;
-	/**
-	 * is called when a domain registered all the elements
-	 */
-	virtual void hookSystemDomainRegistrationComplete(const am_domainID_t domainID) =0;
-	/**
-	 * is called when a routing adaptor registers a sink
-	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
-	 * exists
-	 */
-	virtual am_Error_e hookSystemRegisterSink(const am_Sink_s& sinkData, am_sinkID_t& sinkID) =0;
-	/**
-	 * is called when a routing adaptor deregisters a sink
-	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
-	 */
-	virtual am_Error_e hookSystemDeregisterSink(const am_sinkID_t sinkID) =0;
-	/**
-	 * is called when a routing adaptor registers a source
-	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
-	 * exists
-	 */
-	virtual am_Error_e hookSystemRegisterSource(const am_Source_s& sourceData, am_sourceID_t& sourceID) =0;
-	/**
-	 * is called when a routing adaptor deregisters a source
-	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
-	 */
-	virtual am_Error_e hookSystemDeregisterSource(const am_sourceID_t sourceID) =0;
-	/**
-	 * is called when a routing adaptor registers a converter
-	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
-	 * exists
-	 */
-	virtual am_Error_e hookSystemRegisterConverter(const am_Converter_s& converterData, am_converterID_t& converterID) =0;
-	/**
-	 * is called when a routing adaptor registers a gateway
-	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
-	 * exists
-	 */
-	virtual am_Error_e hookSystemRegisterGateway(const am_Gateway_s& gatewayData, am_gatewayID_t& gatewayID) =0;
-	/**
-	 * is called when a routing adaptor deregisters a converter
-	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
-	 */
-	virtual am_Error_e hookSystemDeregisterConverter(const am_converterID_t converterID) =0;
-	/**
-	 * is called when a routing adaptor deregisters a gateway
-	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
-	 */
-	virtual am_Error_e hookSystemDeregisterGateway(const am_gatewayID_t gatewayID) =0;
-	/**
-	 * is called when a routing adaptor registers a crossfader
-	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
-	 * exists
-	 */
-	virtual am_Error_e hookSystemRegisterCrossfader(const am_Crossfader_s& crossfaderData, am_crossfaderID_t& crossfaderID) =0;
-	/**
-	 * is called when a routing adaptor deregisters a crossfader
-	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
-	 */
-	virtual am_Error_e hookSystemDeregisterCrossfader(const am_crossfaderID_t crossfaderID) =0;
-	/**
-	 * volumeticks. therse are used to indicate volumechanges during a ramp
-	 */
-	virtual void hookSystemSinkVolumeTick(const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume) =0;
-	/**
-	 * volumeticks. therse are used to indicate volumechanges during a ramp
-	 */
-	virtual void hookSystemSourceVolumeTick(const am_Handle_s handle, const am_sourceID_t sourceID, const am_volume_t volume) =0;
-	/**
-	 * is called when an low level interrupt changed its state
-	 */
-	virtual void hookSystemInterruptStateChange(const am_sourceID_t sourceID, const am_InterruptState_e interruptState) =0;
-	/**
-	 * id called when a sink changed its availability
-	 */
-	virtual void hookSystemSinkAvailablityStateChange(const am_sinkID_t sinkID, const am_Availability_s& availability) =0;
-	/**
-	 * id called when a source changed its availability
-	 */
-	virtual void hookSystemSourceAvailablityStateChange(const am_sourceID_t sourceID, const am_Availability_s& availability) =0;
-	/**
-	 * id called when domainstate was changed
-	 */
-	virtual void hookSystemDomainStateChange(const am_domainID_t domainID, const am_DomainState_e state) =0;
-	/**
-	 * when early data was received
-	 */
-	virtual void hookSystemReceiveEarlyData(const std::vector<am_EarlyData_s>& data) =0;
-	/**
-	 * this hook provides information about speed changes.
-	 * The quantization and sampling rate of the speed can be adjusted at compile time
-	 * of the AudioManagerDaemon.
-	 */
-	virtual void hookSystemSpeedChange(const am_speed_t speed) =0;
-	/**
-	 * this hook is fired whenever the timing information of a mainconnection has
-	 * changed.
-	 */
-	virtual void hookSystemTimingInformationChanged(const am_mainConnectionID_t mainConnectionID, const am_timeSync_t time) =0;
-	/**
-	 * ack for connect
-	 */
-	virtual void cbAckConnect(const am_Handle_s handle, const am_Error_e errorID) =0;
-	/**
-	 * ack for disconnect
-	 */
-	virtual void cbAckDisconnect(const am_Handle_s handle, const am_Error_e errorID) =0;
-	/**
-	 * ack for crossfading
-	 */
-	virtual void cbAckCrossFade(const am_Handle_s handle, const am_HotSink_e hostsink, const am_Error_e error) =0;
-	/**
-	 * ack for sink volume changes
-	 */
-	virtual void cbAckSetSinkVolumeChange(const am_Handle_s handle, const am_volume_t volume, const am_Error_e error) =0;
-	/**
-	 * ack for source volume changes
-	 */
-	virtual void cbAckSetSourceVolumeChange(const am_Handle_s handle, const am_volume_t voulme, const am_Error_e error) =0;
-	/**
-	 * ack for setting of source states
-	 */
-	virtual void cbAckSetSourceState(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * ack for setting of sourcesoundproperties
-	 */
-	virtual void cbAckSetSourceSoundProperties(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * ack for setting of sourcesoundproperties
-	 */
-	virtual void cbAckSetSourceSoundProperty(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * ack for setting of sinksoundproperties
-	 */
-	virtual void cbAckSetSinkSoundProperties(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * ack for setting of sinksoundproperties
-	 */
-	virtual void cbAckSetSinkSoundProperty(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * This function is used by the routing algorithm to retrieve a priorized list of
-	 * connectionFormats from the Controller.
-	 * @return E_OK in case of successfull priorisation.
-	 */
-	virtual am_Error_e getConnectionFormatChoice(const am_sourceID_t sourceID, const am_sinkID_t sinkID, const am_Route_s listRoute, const std::vector<am_CustomConnectionFormat_t> listPossibleConnectionFormats, std::vector<am_CustomConnectionFormat_t>& listPrioConnectionFormats) =0;
-	/**
-	 * confirms the setCommandReady call
-	 */
-	virtual void confirmCommandReady(const am_Error_e error) =0;
-	/**
-	 * confirms the setRoutingReady call
-	 */
-	virtual void confirmRoutingReady(const am_Error_e error) =0;
-	/**
-	 * confirms the setCommandRundown call
-	 */
-	virtual void confirmCommandRundown(const am_Error_e error) =0;
-	/**
-	 * confirms the setRoutingRundown command
-	 */
-	virtual void confirmRoutingRundown(const am_Error_e error) =0;
-	/**
-	 * update form the SinkData
-	 */
-	virtual am_Error_e hookSystemUpdateSink(const am_sinkID_t sinkID, const am_sinkClass_t sinkClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
-	/**
-	 * update from the source Data
-	 */
-	virtual am_Error_e hookSystemUpdateSource(const am_sourceID_t sourceID, const am_sourceClass_t sourceClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
-	/**
-	 * updates the Converter Data
-	 */
-	virtual am_Error_e hookSystemUpdateConverter(const am_converterID_t converterID, const std::vector<am_CustomConnectionFormat_t>& listSourceConnectionFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkConnectionFormats, const std::vector<bool>& convertionMatrix) =0;
-	/**
-	 * updates the Gateway Data
-	 */
-	virtual am_Error_e hookSystemUpdateGateway(const am_gatewayID_t gatewayID, const std::vector<am_CustomConnectionFormat_t>& listSourceConnectionFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkConnectionFormats, const std::vector<bool>& convertionMatrix) =0;
-	/**
-	 * ack for mulitple volume changes
-	 */
-	virtual void cbAckSetVolumes(const am_Handle_s handle, const std::vector<am_Volumes_s>& listVolumes, const am_Error_e error) =0;
-	/**
-	 * The acknowledge of the sink notification configuration
-	 */
-	virtual void cbAckSetSinkNotificationConfiguration(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * The acknowledge of the source notification configuration
-	 */
-	virtual void cbAckSetSourceNotificationConfiguration(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * new sinkNotification data is there!
-	 */
-	virtual void hookSinkNotificationDataChanged(const am_sinkID_t sinkID, const am_NotificationPayload_s& payload) =0;
-	/**
-	 * new sourceNotification data is there!
-	 */
-	virtual void hookSourceNotificationDataChanged(const am_sourceID_t sourceID, const am_NotificationPayload_s& payload) =0;
-	/**
-	 * sets a user MainSinkNotificationConfiguration
-	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
-	 */
-	virtual am_Error_e hookUserSetMainSinkNotificationConfiguration(const am_sinkID_t sinkID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
-	/**
-	 * sets a user MainSourceNotificationConfiguration
-	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
-	 */
-	virtual am_Error_e hookUserSetMainSourceNotificationConfiguration(const am_sourceID_t sourceID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
-	/**
-	 * This hook is connected to the NodeState signal of the NodeStateManager
-	 */
-	virtual void hookSystemNodeStateChanged(const NsmNodeState_e NodeStateId) =0;
-	/**
-	 * This hook is connected to the NodeApplicationMode signal of the NodeStateManager
-	 */
-	virtual void hookSystemNodeApplicationModeChanged(const NsmApplicationMode_e ApplicationModeId) =0;
-	/**
-	 * the sessionstate change was send by the NSM
-	 */
-	virtual void hookSystemSessionStateChanged(const std::string& sessionName, const NsmSeat_e seatID, const NsmSessionState_e sessionStateID) =0;
-	/**
-	 * A lifecycle request comes in from the NSM and must be processed.
-	 * @return NsmErrorStatus_Ok if successful
-	 * The controller has to respond to this message with LifecycleRequestComplete.
-	 */
-	virtual NsmErrorStatus_e hookSystemLifecycleRequest(const uint32_t Request, const uint32_t RequestId) =0;
-	/**
-	 * This hook is fired whenever the timing information of a connection has changed.
-	 */
-	virtual void hookSystemSingleTimingInformationChanged(const am_connectionID_t connectionID, const am_timeSync_t time) =0;
-
-};
-}
-#endif // !defined(EA_69597D9E_B0A3_4c6d_BBB6_E7F436B8B799__INCLUDED_)
+	/**
+	 * sets a user volume as increment
+	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
+	 */
+	virtual am_Error_e hookUserVolumeStep(const am_sinkID_t SinkID, const int16_t increment) =0;
+	/**
+	 * sets the mute state of a sink
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e hookUserSetSinkMuteState(const am_sinkID_t sinkID, const am_MuteState_e muteState) =0;
+	/**
+	 * is called when a routing adaptor registers its domain
+	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
+	 * exists
+	 */
+	virtual am_Error_e hookSystemRegisterDomain(const am_Domain_s& domainData, am_domainID_t& domainID) =0;
+	/**
+	 * is called when a routing adaptor wants to derigister a domain
+	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
+	 */
+	virtual am_Error_e hookSystemDeregisterDomain(const am_domainID_t domainID) =0;
+	/**
+	 * is called when a domain registered all the elements
+	 */
+	virtual void hookSystemDomainRegistrationComplete(const am_domainID_t domainID) =0;
+	/**
+	 * is called when a routing adaptor registers a sink
+	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
+	 * exists
+	 */
+	virtual am_Error_e hookSystemRegisterSink(const am_Sink_s& sinkData, am_sinkID_t& sinkID) =0;
+	/**
+	 * is called when a routing adaptor deregisters a sink
+	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
+	 */
+	virtual am_Error_e hookSystemDeregisterSink(const am_sinkID_t sinkID) =0;
+	/**
+	 * is called when a routing adaptor registers a source
+	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
+	 * exists
+	 */
+	virtual am_Error_e hookSystemRegisterSource(const am_Source_s& sourceData, am_sourceID_t& sourceID) =0;
+	/**
+	 * is called when a routing adaptor deregisters a source
+	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
+	 */
+	virtual am_Error_e hookSystemDeregisterSource(const am_sourceID_t sourceID) =0;
+	/**
+	 * is called when a routing adaptor registers a converter
+	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
+	 * exists
+	 */
+	virtual am_Error_e hookSystemRegisterConverter(const am_Converter_s& converterData, am_converterID_t& converterID) =0;
+	/**
+	 * is called when a routing adaptor registers a gateway
+	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
+	 * exists
+	 */
+	virtual am_Error_e hookSystemRegisterGateway(const am_Gateway_s& gatewayData, am_gatewayID_t& gatewayID) =0;
+	/**
+	 * is called when a routing adaptor deregisters a converter
+	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
+	 */
+	virtual am_Error_e hookSystemDeregisterConverter(const am_converterID_t converterID) =0;
+	/**
+	 * is called when a routing adaptor deregisters a gateway
+	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
+	 */
+	virtual am_Error_e hookSystemDeregisterGateway(const am_gatewayID_t gatewayID) =0;
+	/**
+	 * is called when a routing adaptor registers a crossfader
+	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXISTENT if already
+	 * exists
+	 */
+	virtual am_Error_e hookSystemRegisterCrossfader(const am_Crossfader_s& crossfaderData, am_crossfaderID_t& crossfaderID) =0;
+	/**
+	 * is called when a routing adaptor deregisters a crossfader
+	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if not found
+	 */
+	virtual am_Error_e hookSystemDeregisterCrossfader(const am_crossfaderID_t crossfaderID) =0;
+	/**
+	 * volumeticks. therse are used to indicate volumechanges during a ramp
+	 */
+	virtual void hookSystemSinkVolumeTick(const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume) =0;
+	/**
+	 * volumeticks. therse are used to indicate volumechanges during a ramp
+	 */
+	virtual void hookSystemSourceVolumeTick(const am_Handle_s handle, const am_sourceID_t sourceID, const am_volume_t volume) =0;
+	/**
+	 * is called when an low level interrupt changed its state
+	 */
+	virtual void hookSystemInterruptStateChange(const am_sourceID_t sourceID, const am_InterruptState_e interruptState) =0;
+	/**
+	 * id called when a sink changed its availability
+	 */
+	virtual void hookSystemSinkAvailablityStateChange(const am_sinkID_t sinkID, const am_Availability_s& availability) =0;
+	/**
+	 * id called when a source changed its availability
+	 */
+	virtual void hookSystemSourceAvailablityStateChange(const am_sourceID_t sourceID, const am_Availability_s& availability) =0;
+	/**
+	 * id called when domainstate was changed
+	 */
+	virtual void hookSystemDomainStateChange(const am_domainID_t domainID, const am_DomainState_e state) =0;
+	/**
+	 * when early data was received
+	 */
+	virtual void hookSystemReceiveEarlyData(const std::vector<am_EarlyData_s>& data) =0;
+	/**
+	 * this hook provides information about speed changes.
+	 * The quantization and sampling rate of the speed can be adjusted at compile time
+	 * of the AudioManagerDaemon.
+	 */
+	virtual void hookSystemSpeedChange(const am_speed_t speed) =0;
+	/**
+	 * this hook is fired whenever the timing information of a mainconnection has
+	 * changed.
+	 */
+	virtual void hookSystemTimingInformationChanged(const am_mainConnectionID_t mainConnectionID, const am_timeSync_t time) =0;
+	/**
+	 * ack for connect
+	 */
+	virtual void cbAckConnect(const am_Handle_s handle, const am_Error_e errorID) =0;
+	/**
+	 * ack for disconnect
+	 */
+	virtual void cbAckDisconnect(const am_Handle_s handle, const am_Error_e errorID) =0;
+	/**
+	 * ack for crossfading
+	 */
+	virtual void cbAckCrossFade(const am_Handle_s handle, const am_HotSink_e hostsink, const am_Error_e error) =0;
+	/**
+	 * ack for sink volume changes
+	 */
+	virtual void cbAckSetSinkVolumeChange(const am_Handle_s handle, const am_volume_t volume, const am_Error_e error) =0;
+	/**
+	 * ack for source volume changes
+	 */
+	virtual void cbAckSetSourceVolumeChange(const am_Handle_s handle, const am_volume_t voulme, const am_Error_e error) =0;
+	/**
+	 * ack for setting of source states
+	 */
+	virtual void cbAckSetSourceState(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * ack for setting of sourcesoundproperties
+	 */
+	virtual void cbAckSetSourceSoundProperties(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * ack for setting of sourcesoundproperties
+	 */
+	virtual void cbAckSetSourceSoundProperty(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * ack for setting of sinksoundproperties
+	 */
+	virtual void cbAckSetSinkSoundProperties(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * ack for setting of sinksoundproperties
+	 */
+	virtual void cbAckSetSinkSoundProperty(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * This function is used by the routing algorithm to retrieve a priorized list of
+	 * connectionFormats from the Controller.
+	 * @return E_OK in case of successfull priorisation.
+	 */
+	virtual am_Error_e getConnectionFormatChoice(const am_sourceID_t sourceID, const am_sinkID_t sinkID, const am_Route_s listRoute, const std::vector<am_CustomConnectionFormat_t> listPossibleConnectionFormats, std::vector<am_CustomConnectionFormat_t>& listPrioConnectionFormats) =0;
+	/**
+	 * confirms the setCommandReady call
+	 */
+	virtual void confirmCommandReady(const am_Error_e error) =0;
+	/**
+	 * confirms the setRoutingReady call
+	 */
+	virtual void confirmRoutingReady(const am_Error_e error) =0;
+	/**
+	 * confirms the setCommandRundown call
+	 */
+	virtual void confirmCommandRundown(const am_Error_e error) =0;
+	/**
+	 * confirms the setRoutingRundown command
+	 */
+	virtual void confirmRoutingRundown(const am_Error_e error) =0;
+	/**
+	 * update form the SinkData
+	 */
+	virtual am_Error_e hookSystemUpdateSink(const am_sinkID_t sinkID, const am_sinkClass_t sinkClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
+	/**
+	 * update from the source Data
+	 */
+	virtual am_Error_e hookSystemUpdateSource(const am_sourceID_t sourceID, const am_sourceClass_t sourceClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
+	/**
+	 * updates the Converter Data
+	 */
+	virtual am_Error_e hookSystemUpdateConverter(const am_converterID_t converterID, const std::vector<am_CustomConnectionFormat_t>& listSourceConnectionFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkConnectionFormats, const std::vector<bool>& convertionMatrix) =0;
+	/**
+	 * updates the Gateway Data
+	 */
+	virtual am_Error_e hookSystemUpdateGateway(const am_gatewayID_t gatewayID, const std::vector<am_CustomConnectionFormat_t>& listSourceConnectionFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkConnectionFormats, const std::vector<bool>& convertionMatrix) =0;
+	/**
+	 * ack for mulitple volume changes
+	 */
+	virtual void cbAckSetVolumes(const am_Handle_s handle, const std::vector<am_Volumes_s>& listVolumes, const am_Error_e error) =0;
+	/**
+	 * The acknowledge of the sink notification configuration
+	 */
+	virtual void cbAckSetSinkNotificationConfiguration(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * The acknowledge of the source notification configuration
+	 */
+	virtual void cbAckSetSourceNotificationConfiguration(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * new sinkNotification data is there!
+	 */
+	virtual void hookSinkNotificationDataChanged(const am_sinkID_t sinkID, const am_NotificationPayload_s& payload) =0;
+	/**
+	 * new sourceNotification data is there!
+	 */
+	virtual void hookSourceNotificationDataChanged(const am_sourceID_t sourceID, const am_NotificationPayload_s& payload) =0;
+	/**
+	 * sets a user MainSinkNotificationConfiguration
+	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
+	 */
+	virtual am_Error_e hookUserSetMainSinkNotificationConfiguration(const am_sinkID_t sinkID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
+	/**
+	 * sets a user MainSourceNotificationConfiguration
+	 * @return E_OK on success, E_OUT_OF_RANGE if out of range, E_UNKNOWN on error
+	 */
+	virtual am_Error_e hookUserSetMainSourceNotificationConfiguration(const am_sourceID_t sourceID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
+	/**
+	 * This hook is connected to the NodeState signal of the NodeStateManager
+	 */
+	virtual void hookSystemNodeStateChanged(const NsmNodeState_e NodeStateId) =0;
+	/**
+	 * This hook is connected to the NodeApplicationMode signal of the NodeStateManager
+	 */
+	virtual void hookSystemNodeApplicationModeChanged(const NsmApplicationMode_e ApplicationModeId) =0;
+	/**
+	 * the sessionstate change was send by the NSM
+	 */
+	virtual void hookSystemSessionStateChanged(const std::string& sessionName, const NsmSeat_e seatID, const NsmSessionState_e sessionStateID) =0;
+	/**
+	 * A lifecycle request comes in from the NSM and must be processed.
+	 * @return NsmErrorStatus_Ok if successful
+	 * The controller has to respond to this message with LifecycleRequestComplete.
+	 */
+	virtual NsmErrorStatus_e hookSystemLifecycleRequest(const uint32_t Request, const uint32_t RequestId) =0;
+	/**
+	 * This hook is fired whenever the timing information of a connection has changed.
+	 */
+	virtual void hookSystemSingleTimingInformationChanged(const am_connectionID_t connectionID, const am_timeSync_t time) =0;
+
+};
+}
+#endif // !defined(EA_69597D9E_B0A3_4c6d_BBB6_E7F436B8B799__INCLUDED_)
diff --git a/include/IAmRouting.h b/include/IAmRouting.h
index 60baa5e..1261910 100644
--- a/include/IAmRouting.h
+++ b/include/IAmRouting.h
@@ -1,496 +1,496 @@
-/**
- * Copyright (C) 2012 - 2014, BMW AG
- *
- * This file is part of GENIVI Project AudioManager.
- *
- * Contributions are licensed to the GENIVI Alliance under one or more
- * Contribution License Agreements.
- *
- * \copyright
- * This Source Code Form is subject to the terms of the
- * Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
- * this file, You can obtain one at http://mozilla.org/MPL/2.0/.
- *
- *
- * \author Christian Linke, christian.linke@bmw.de BMW 2011 - 2014
- *
- * \file
- * For further information see http://projects.genivi.org/audio-manager
- *
- * THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. 
- * PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN.
- */
-#if !defined(EA_6B9C54C0_2366_4139_97CF_28563364DACA__INCLUDED_)
-#define EA_6B9C54C0_2366_4139_97CF_28563364DACA__INCLUDED_
-
-#include <vector>
-#include <string>
-#include "audiomanagertypes.h"
-
-namespace am {
-class CAmDbusWrapper;
-class CAmSocketHandler;
-}
-
-
-#include "audiomanagertypes.h"
-
-#define RoutingVersion "4.0" 
-namespace am {
-
-/**
- * Routing Receive sendInterface description. This class implements everything
- * from RoutingAdapter -> Audiomanager
- * There are two rules that have to be kept in mind when implementing against this
- * interface:\n
- * \warning
- * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
- * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
- * CALL THAT EXPECTS A RETURN VALUE.\n
- * \details
- * Violation these rules may lead to unexpected behavior! Nevertheless you can
- * implement thread safe by using the deferred-call pattern described on the wiki
- * which also helps to implement calls that are forbidden.\n
- * For more information, please check CAmSerializer
- */
-class IAmRoutingReceive
-{
-
-public:
-	IAmRoutingReceive() {
-
-	}
-
-	virtual ~IAmRoutingReceive() {
-
-	}
-
-	/**
-	 * This function returns the version of the interface
-	 */
-	virtual void  getInterfaceVersion(std::string& version) const =0;
-	/**
-	 * acknowledges a asyncConnect
-	 */
-	virtual void ackConnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_Error_e error) =0;
-	/**
-	 * acknowledges a asyncDisconnect
-	 */
-	virtual void ackDisconnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_Error_e error) =0;
-	/**
-	 * acknowledges a asyncsetSinkVolume 
-	 */
-	virtual void ackSetSinkVolumeChange(const am_Handle_s handle, const am_volume_t volume, const am_Error_e error) =0;
-	/**
-	 * acknowledges a asyncsetSourceVolume
-	 */
-	virtual void ackSetSourceVolumeChange(const am_Handle_s handle, const am_volume_t volume, const am_Error_e error) =0;
-	/**
-	 * acknowlegde for asyncSetSourceState
-	 */
-	virtual void ackSetSourceState(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * acknowledges asyncSetSinkSoundProperties
-	 */
-	virtual void ackSetSinkSoundProperties(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * acknowledges asyncSetSinkSoundProperty
-	 */
-	virtual void ackSetSinkSoundProperty(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * acknowledges asyncSetSourceSoundProperties
-	 */
-	virtual void ackSetSourceSoundProperties(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * acknowledges asyncSetSourceSoundProperty
-	 */
-	virtual void ackSetSourceSoundProperty(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * acknowledges asyncCrossFade
-	 */
-	virtual void ackCrossFading(const am_Handle_s handle, const am_HotSink_e hotSink, const am_Error_e error) =0;
-	/**
-	 * acknowledges a volume tick. This can be used to display volumechanges during
-	 * ramps
-	 */
-	virtual void ackSourceVolumeTick(const am_Handle_s handle, const am_sourceID_t sourceID, const am_volume_t volume) =0;
-	/**
-	 * acknowledges a volume tick. This can be used to display volumechanges during
-	 * ramps
-	 */
-	virtual void ackSinkVolumeTick(const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume) =0;
-	/**
-	 * This function returns the ID to the given domainName. If already a domain is
-	 * registered with this name, it will return the corresponding ID, if not it will
-	 * reserve an ID but not register the domain. The other parameters of the domain
-	 * will be overwritten when the domain is registered.
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e peekDomain(const std::string& name, am_domainID_t& domainID) =0;
-	/**
-	 * registers a domain
-	 * @return E_OK on succes, E_ALREADY_EXISTENT if already registered E_UNKOWN on
-	 * error
-	 */
-	virtual am_Error_e registerDomain(const am_Domain_s& domainData, am_domainID_t& domainID) =0;
-	/**
-	 * deregisters a domain. All sources, sinks, gateways and crossfaders from that
-	 * domain will be removed as well.
-	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
-	 */
-	virtual am_Error_e deregisterDomain(const am_domainID_t domainID) =0;
-	/**
-	 * registers a converter. @return E_OK on succes, E_ALREADY_EXISTENT if already
-	 * registered E_UNKOWN on error
-	 */
-	virtual am_Error_e registerConverter(const am_Converter_s& converterData, am_converterID_t& converterID) =0;
-	/**
-	 * registers a gateway. @return E_OK on succes, E_ALREADY_EXISTENT if already
-	 * registered E_UNKOWN on error
-	 */
-	virtual am_Error_e registerGateway(const am_Gateway_s& gatewayData, am_gatewayID_t& gatewayID) =0;
-	/**
-	 * deregisters a converter. Also removes all sinks and sources of the controlling
-	 * domain.
-	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
-	 */
-	virtual am_Error_e deregisterConverter(const am_converterID_t converterID) =0;
-	/**
-	 * deregisters a gateway. Also removes all sinks and sources of the controlling
-	 * domain.
-	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
-	 */
-	virtual am_Error_e deregisterGateway(const am_gatewayID_t gatewayID) =0;
-	/**
-	 * This function returns the ID to the given sinkName. If already a sink is
-	 * registered with this name, it will return the corresponding ID, if not it will
-	 * reserve an ID but not register the sink. The other parameters of the sink will
-	 * be overwritten when the sink is registered.
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e peekSink(const std::string& name, am_sinkID_t& sinkID) =0;
-	/**
-	 * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
-	 * is copied to the gatewayInformation
-	 * @return E_OK on succes, E_ALREADY_EXISTENT if already registered E_UNKOWN on
-	 * error
-	 */
-	virtual am_Error_e registerSink(const am_Sink_s& sinkData, am_sinkID_t& sinkID) =0;
-	/**
-	 * deregisters a sink.
-	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
-	 */
-	virtual am_Error_e deregisterSink(const am_sinkID_t sinkID) =0;
-	/**
-	 * This function returns the ID to the given sourceName. If already a source is
-	 * registered with this name, it will return the corresponding ID, if not it will
-	 * reserve an ID but not register the source. The other parameters of the source
-	 * will be overwritten when the source is registered.
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e peekSource(const std::string& name, am_sourceID_t& sourceID) =0;
-	/**
-	 * registers a source.  If the source is part of a gateway, the
-	 * listconnectionFormats is copied to the gatewayInformation
-	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or
-	 * sourceID already exists
-	 */
-	virtual am_Error_e registerSource(const am_Source_s& sourceData, am_sourceID_t& sourceID) =0;
-	/**
-	 * deregisters a source
-	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
-	 */
-	virtual am_Error_e deregisterSource(const am_sourceID_t sourceID) =0;
-	/**
-	 * this function registers a crossfader.
-	 * @return E_OK on succes, E_ALREADY_EXISTENT if already registered E_UNKOWN on
-	 * error
-	 */
-	virtual am_Error_e registerCrossfader(const am_Crossfader_s& crossfaderData, am_crossfaderID_t& crossfaderID) =0;
-	/**
-	 * this function deregisters a crossfader. removes all sources and sinks assiated
-	 * as well.
-	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
-	 */
-	virtual am_Error_e deregisterCrossfader(const am_crossfaderID_t crossfaderID) =0;
-	/**
-	 * this function peeks a sourceclassID. It is used by the RoutingPlugins to
-	 * determine the SinkClassIDs of a sinkClass.
-	 * @return E_OK on succes, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e peekSourceClassID(const std::string& name, am_sourceClass_t& sourceClassID) =0;
-	/**
-	 * this function peeks a sourceclassID. It is used by the RoutingPlugins to
-	 * determine the SinkClassIDs of a sinkClass.
-	 * @return E_OK on succes, E_DATABASE_ERROR on error
-	 */
-	virtual am_Error_e peekSinkClassID(const std::string& name, am_sinkClass_t& sinkClassID) =0;
-	/**
-	 * is called when a low level interrupt changes it status.
-	 */
-	virtual void hookInterruptStatusChange(const am_sourceID_t sourceID, const am_InterruptState_e interruptState) =0;
-	/**
-	 * This hook is called when all elements from a domain are registered.
-	 * Is used by the Controller to know when all expected domains are finally
-	 * registered
-	 */
-	virtual void hookDomainRegistrationComplete(const am_domainID_t domainID) =0;
-	/**
-	 * is called when a sink changes its availability
-	 */
-	virtual void hookSinkAvailablityStatusChange(const am_sinkID_t sinkID, const am_Availability_s& availability) =0;
-	/**
-	 * is called when a source changes its availability
-	 */
-	virtual void hookSourceAvailablityStatusChange(const am_sourceID_t sourceID, const am_Availability_s& availability) =0;
-	/**
-	 * is called when a domain changes its status. This used for early domains only
-	 */
-	virtual void hookDomainStateChange(const am_domainID_t domainID, const am_DomainState_e domainState) =0;
-	/**
-	 * is called when the timinginformation (delay) changed for a connection.
-	 */
-	virtual void hookTimingInformationChanged(const am_connectionID_t connectionID, const am_timeSync_t delay) =0;
+/**
+ * Copyright (C) 2012 - 2014, BMW AG
+ *
+ * This file is part of GENIVI Project AudioManager.
+ *
+ * Contributions are licensed to the GENIVI Alliance under one or more
+ * Contribution License Agreements.
+ *
+ * \copyright
+ * This Source Code Form is subject to the terms of the
+ * Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
+ * this file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ *
+ * \author Christian Linke, christian.linke@bmw.de BMW 2011 - 2014
+ *
+ * \file
+ * For further information see http://projects.genivi.org/audio-manager
+ *
+ * THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. 
+ * PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN.
+ */
+#if !defined(EA_6B9C54C0_2366_4139_97CF_28563364DACA__INCLUDED_)
+#define EA_6B9C54C0_2366_4139_97CF_28563364DACA__INCLUDED_
+
+#include <vector>
+#include <string>
+#include "audiomanagertypes.h"
+
+namespace am {
+class CAmDbusWrapper;
+class CAmSocketHandler;
+}
+
+
+#include "audiomanagertypes.h"
+
+#define RoutingVersion "4.0" 
+namespace am {
+
+/**
+ * Routing Receive sendInterface description. This class implements everything
+ * from RoutingAdapter -> Audiomanager
+ * There are two rules that have to be kept in mind when implementing against this
+ * interface:\n
+ * \warning
+ * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
+ * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
+ * CALL THAT EXPECTS A RETURN VALUE.\n
+ * \details
+ * Violation these rules may lead to unexpected behavior! Nevertheless you can
+ * implement thread safe by using the deferred-call pattern described on the wiki
+ * which also helps to implement calls that are forbidden.\n
+ * For more information, please check CAmSerializer
+ */
+class IAmRoutingReceive
+{
+
+public:
+	IAmRoutingReceive() {
+
+	}
+
+	virtual ~IAmRoutingReceive() {
+
+	}
+
+	/**
+	 * This function returns the version of the interface
+	 */
+	virtual void  getInterfaceVersion(std::string& version) const =0;
+	/**
+	 * acknowledges a asyncConnect
+	 */
+	virtual void ackConnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_Error_e error) =0;
+	/**
+	 * acknowledges a asyncDisconnect
+	 */
+	virtual void ackDisconnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_Error_e error) =0;
+	/**
+	 * acknowledges a asyncsetSinkVolume 
+	 */
+	virtual void ackSetSinkVolumeChange(const am_Handle_s handle, const am_volume_t volume, const am_Error_e error) =0;
+	/**
+	 * acknowledges a asyncsetSourceVolume
+	 */
+	virtual void ackSetSourceVolumeChange(const am_Handle_s handle, const am_volume_t volume, const am_Error_e error) =0;
+	/**
+	 * acknowlegde for asyncSetSourceState
+	 */
+	virtual void ackSetSourceState(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * acknowledges asyncSetSinkSoundProperties
+	 */
+	virtual void ackSetSinkSoundProperties(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * acknowledges asyncSetSinkSoundProperty
+	 */
+	virtual void ackSetSinkSoundProperty(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * acknowledges asyncSetSourceSoundProperties
+	 */
+	virtual void ackSetSourceSoundProperties(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * acknowledges asyncSetSourceSoundProperty
+	 */
+	virtual void ackSetSourceSoundProperty(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * acknowledges asyncCrossFade
+	 */
+	virtual void ackCrossFading(const am_Handle_s handle, const am_HotSink_e hotSink, const am_Error_e error) =0;
+	/**
+	 * acknowledges a volume tick. This can be used to display volumechanges during
+	 * ramps
+	 */
+	virtual void ackSourceVolumeTick(const am_Handle_s handle, const am_sourceID_t sourceID, const am_volume_t volume) =0;
+	/**
+	 * acknowledges a volume tick. This can be used to display volumechanges during
+	 * ramps
+	 */
+	virtual void ackSinkVolumeTick(const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume) =0;
+	/**
+	 * This function returns the ID to the given domainName. If already a domain is
+	 * registered with this name, it will return the corresponding ID, if not it will
+	 * reserve an ID but not register the domain. The other parameters of the domain
+	 * will be overwritten when the domain is registered.
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e peekDomain(const std::string& name, am_domainID_t& domainID) =0;
+	/**
+	 * registers a domain
+	 * @return E_OK on succes, E_ALREADY_EXISTENT if already registered E_UNKOWN on
+	 * error
+	 */
+	virtual am_Error_e registerDomain(const am_Domain_s& domainData, am_domainID_t& domainID) =0;
+	/**
+	 * deregisters a domain. All sources, sinks, gateways and crossfaders from that
+	 * domain will be removed as well.
+	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
+	 */
+	virtual am_Error_e deregisterDomain(const am_domainID_t domainID) =0;
+	/**
+	 * registers a converter. @return E_OK on succes, E_ALREADY_EXISTENT if already
+	 * registered E_UNKOWN on error
+	 */
+	virtual am_Error_e registerConverter(const am_Converter_s& converterData, am_converterID_t& converterID) =0;
+	/**
+	 * registers a gateway. @return E_OK on succes, E_ALREADY_EXISTENT if already
+	 * registered E_UNKOWN on error
+	 */
+	virtual am_Error_e registerGateway(const am_Gateway_s& gatewayData, am_gatewayID_t& gatewayID) =0;
+	/**
+	 * deregisters a converter. Also removes all sinks and sources of the controlling
+	 * domain.
+	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
+	 */
+	virtual am_Error_e deregisterConverter(const am_converterID_t converterID) =0;
+	/**
+	 * deregisters a gateway. Also removes all sinks and sources of the controlling
+	 * domain.
+	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
+	 */
+	virtual am_Error_e deregisterGateway(const am_gatewayID_t gatewayID) =0;
+	/**
+	 * This function returns the ID to the given sinkName. If already a sink is
+	 * registered with this name, it will return the corresponding ID, if not it will
+	 * reserve an ID but not register the sink. The other parameters of the sink will
+	 * be overwritten when the sink is registered.
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e peekSink(const std::string& name, am_sinkID_t& sinkID) =0;
+	/**
+	 * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
+	 * is copied to the gatewayInformation
+	 * @return E_OK on succes, E_ALREADY_EXISTENT if already registered E_UNKOWN on
+	 * error
+	 */
+	virtual am_Error_e registerSink(const am_Sink_s& sinkData, am_sinkID_t& sinkID) =0;
+	/**
+	 * deregisters a sink.
+	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
+	 */
+	virtual am_Error_e deregisterSink(const am_sinkID_t sinkID) =0;
+	/**
+	 * This function returns the ID to the given sourceName. If already a source is
+	 * registered with this name, it will return the corresponding ID, if not it will
+	 * reserve an ID but not register the source. The other parameters of the source
+	 * will be overwritten when the source is registered.
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e peekSource(const std::string& name, am_sourceID_t& sourceID) =0;
+	/**
+	 * registers a source.  If the source is part of a gateway, the
+	 * listconnectionFormats is copied to the gatewayInformation
+	 * @return E_OK on success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or
+	 * sourceID already exists
+	 */
+	virtual am_Error_e registerSource(const am_Source_s& sourceData, am_sourceID_t& sourceID) =0;
+	/**
+	 * deregisters a source
+	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
+	 */
+	virtual am_Error_e deregisterSource(const am_sourceID_t sourceID) =0;
+	/**
+	 * this function registers a crossfader.
+	 * @return E_OK on succes, E_ALREADY_EXISTENT if already registered E_UNKOWN on
+	 * error
+	 */
+	virtual am_Error_e registerCrossfader(const am_Crossfader_s& crossfaderData, am_crossfaderID_t& crossfaderID) =0;
+	/**
+	 * this function deregisters a crossfader. removes all sources and sinks assiated
+	 * as well.
+	 * @return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on error
+	 */
+	virtual am_Error_e deregisterCrossfader(const am_crossfaderID_t crossfaderID) =0;
+	/**
+	 * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+	 * determine the SinkClassIDs of a sinkClass.
+	 * @return E_OK on succes, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e peekSourceClassID(const std::string& name, am_sourceClass_t& sourceClassID) =0;
+	/**
+	 * this function peeks a sourceclassID. It is used by the RoutingPlugins to
+	 * determine the SinkClassIDs of a sinkClass.
+	 * @return E_OK on succes, E_DATABASE_ERROR on error
+	 */
+	virtual am_Error_e peekSinkClassID(const std::string& name, am_sinkClass_t& sinkClassID) =0;
+	/**
+	 * is called when a low level interrupt changes it status.
+	 */
+	virtual void hookInterruptStatusChange(const am_sourceID_t sourceID, const am_InterruptState_e interruptState) =0;
+	/**
+	 * This hook is called when all elements from a domain are registered.
+	 * Is used by the Controller to know when all expected domains are finally
+	 * registered
+	 */
+	virtual void hookDomainRegistrationComplete(const am_domainID_t domainID) =0;
+	/**
+	 * is called when a sink changes its availability
+	 */
+	virtual void hookSinkAvailablityStatusChange(const am_sinkID_t sinkID, const am_Availability_s& availability) =0;
+	/**
+	 * is called when a source changes its availability
+	 */
+	virtual void hookSourceAvailablityStatusChange(const am_sourceID_t sourceID, const am_Availability_s& availability) =0;
+	/**
+	 * is called when a domain changes its status. This used for early domains only
+	 */
+	virtual void hookDomainStateChange(const am_domainID_t domainID, const am_DomainState_e domainState) =0;
+	/**
+	 * is called when the timinginformation (delay) changed for a connection.
+	 */
+	virtual void hookTimingInformationChanged(const am_connectionID_t connectionID, const am_timeSync_t delay) =0;
 	/**
 	 * is called when the pulseaudio request connection.
 	 */
-	virtual void hookPulseConnectionRequest(const am_sourceID_t sourceID, const am_sinkID_t sinkID, am_mainConnectionID_t & mainConnectionID) =0;
+	virtual void hookPulseConnectionRequest(const am_sourceID_t sourceID, const am_sinkID_t sinkID, am_mainConnectionID_t & mainConnectionID, const am_volume_t volume) =0;
 	/**
 	 * is called when the pulseaudio request disconnection.
 	 */
 	virtual void hookPulseDisconnectionRequest(const am_mainConnectionID_t mainConnectionID) =0;
-	/**
-	 * this function is used to send out all data that has been changed in an early
-	 * state.
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual void sendChangedData(const std::vector<am_EarlyData_s>& earlyData) =0;
-	/**
-	 * this function is used to retrieve a pointer to the dBusConnectionWrapper
-	 * @return E_OK if pointer is valid, E_UKNOWN if AudioManager was compiled without
-	 * DBus Support
-	 */
-	virtual am_Error_e getDBusConnectionWrapper(CAmDbusWrapper*& dbusConnectionWrapper) const =0;
-	/**
-	 * This function returns the pointer to the socketHandler. This can be used to
-	 * integrate socket-based activites like communication with the mainloop of the
-	 * AudioManager.
-	 * returns E_OK if pointer is valid, E_UNKNOWN in case AudioManager was compiled
-	 * without socketHandler support,
-	 */
-	virtual am_Error_e getSocketHandler(CAmSocketHandler*& socketHandler) const =0;
-	/**
-	 * confirms the setRoutingReady Command
-	 */
-	virtual void  confirmRoutingReady(const uint16_t handle, const am_Error_e error) =0;
-	/**
-	 * confirms the setRoutingRundown Command
-	 */
-	virtual void  confirmRoutingRundown(const uint16_t handle, const am_Error_e error) =0;
-	/**
-	 * updates data of an converter. @return E_OK on success, E_NON_EXISTENT if the
-	 * gatewayID is not valid. 
-	 */
-	virtual am_Error_e updateConverter(const am_converterID_t converterID, const std::vector<am_CustomConnectionFormat_t>& listSourceFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkFormats, const std::vector<bool>& convertionMatrix) =0;
-	/**
-	 * updates data of an gateway. @return E_OK on success, E_NON_EXISTENT if the
-	 * gatewayID is not valid. 
-	 */
-	virtual am_Error_e updateGateway(const am_gatewayID_t gatewayID, const std::vector<am_CustomConnectionFormat_t>& listSourceFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkFormats, const std::vector<bool>& convertionMatrix) =0;
-	/**
-	 * updates data of an gateway. @return E_OK on success, E_NON_EXISTENT if the
-	 * sinkID is not valid.
-	 */
-	virtual am_Error_e updateSink(const am_sinkID_t sinkID, const am_sinkClass_t sinkClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
-	/**
-	 * updates data of an source. @return E_OK on success, E_NON_EXISTENT if the
-	 * sourceID in the struct is not valid.
-	 * Please note that only the following data out of am_Source_s have effect when
-	 * they are changed:
-	 * sourceClassID,
-	 * listSoundProperties,
-	 * listConnectionFormats,
-	 * listMainSoundProperties
-	 */
-	virtual am_Error_e updateSource(const am_sourceID_t sourceID, const am_sourceClass_t sourceClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
-	/**
-	 * acknowledges a asyncSetSinkVolumes
-	 */
-	virtual void ackSetVolumes(const am_Handle_s handle, const std::vector<am_Volumes_s>& listvolumes, const am_Error_e error) =0;
-	/**
-	 * The acknowledge of the SinkNotificationConfiguration
-	 */
-	virtual void ackSinkNotificationConfiguration(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * The acknowledge of the SourceNotificationConfiguration
-	 */
-	virtual void ackSourceNotificationConfiguration(const am_Handle_s handle, const am_Error_e error) =0;
-	/**
-	 * is called whenever a notified value needs to be send
-	 */
-	virtual void hookSinkNotificationDataChange(const am_sinkID_t sinkID, const am_NotificationPayload_s& payload) =0;
-	/**
-	 * is called whenever a notified value needs to be send
-	 */
-	virtual void hookSourceNotificationDataChange(const am_sourceID_t sourceID, const am_NotificationPayload_s& payload) =0;
-	/**
-	 * E_OK in case of success
-	 */
-	virtual am_Error_e getDomainOfSink(const am_sinkID_t sinkID, am_domainID_t& domainID) const =0;
-	/**
-	 * E_OK in case of success
-	 */
-	virtual am_Error_e getDomainOfSource(const am_sourceID_t sourceID, am_domainID_t& domainID) const =0;
-	/**
-	 * E_OK in case of success
-	 */
-	virtual am_Error_e getDomainOfCrossfader(const am_crossfaderID_t crossfader, am_domainID_t& domainID) const = 0;
-
-};
-
-/**
- * This class implements everything from Audiomanager -> RoutingAdapter
- * There are two rules that have to be kept in mind when implementing against this
- * interface:\n
- * \warning
- * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
- * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
- * CALL THAT EXPECTS A RETURN VALUE.\n
- * \details
- * Violation these rules may lead to unexpected behavior! Nevertheless you can
- * implement thread safe by using the deferred-call pattern described on the wiki
- * which also helps to implement calls that are forbidden.\n
- * For more information, please check CAmSerializer
- */
-class IAmRoutingSend
-{
-
-public:
-	IAmRoutingSend() {
-
-	}
-
-	virtual ~IAmRoutingSend() {
-
-	}
-
-	/**
-	 * This function returns the version of the interface
-	 */
-	virtual void getInterfaceVersion(std::string& version) const =0;
-	/**
-	 * starts up the interface. In the implementations, here is the best place for
-	 * init routines.
-	 */
-	virtual am_Error_e startupInterface(IAmRoutingReceive* routingreceiveinterface) =0;
-	/**
-	 * indicates that the routing now ready to be used. Should be used as trigger to
-	 * register all sinks, sources, etc...
-	 */
-	virtual void setRoutingReady(const uint16_t handle) =0;
-	/**
-	 * indicates that the routing plugins need to be prepared to switch the power off
-	 * or be ready again.
-	 */
-	virtual void setRoutingRundown(const uint16_t handle) =0;
-	/**
-	 * aborts an asynchronous action.
-	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if handle was not
-	 * found
-	 */
-	virtual am_Error_e asyncAbort(const am_Handle_s handle) =0;
-	/**
-	 * connects a source to a sink
-	 * @return E_OK on success, E_UNKNOWN on error, E_WRONG_FORMAT in case
-	 * am_ConnectionFormat_e does not match
-	 */
-	virtual am_Error_e asyncConnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_sourceID_t sourceID, const am_sinkID_t sinkID, const am_CustomConnectionFormat_t connectionFormat) =0;
-	/**
-	 * disconnect a connection with given connectionID
-	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if connection was
-	 * not found
-	 */
-	virtual am_Error_e asyncDisconnect(const am_Handle_s handle, const am_connectionID_t connectionID) =0;
-	/**
-	 * this method is used to set the volume of a sink. This function is used to drive
-	 * ramps, to mute or unmute or directly set the value. The difference is made
-	 * through the ramptype.
-	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE if new volume is
-	 * out of range
-	 */
-	virtual am_Error_e asyncSetSinkVolume(const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume, const am_CustomRampType_t ramp, const am_time_t time) =0;
-	/**
-	 * sets the volume of a source. This method is used to set the volume of a sink.
-	 * This function is used to drive ramps, to mute or unmute or directly set the
-	 * value. The difference is made through the ramptype.
-	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
-	 * range.
-	 * triggers the acknowledge ackSourceVolumeChange
-	 */
-	virtual am_Error_e asyncSetSourceVolume(const am_Handle_s handle, const am_sourceID_t sourceID, const am_volume_t volume, const am_CustomRampType_t ramp, const am_time_t time) =0;
-	/**
-	 * This function is used to set the source state of a particular source.
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e asyncSetSourceState(const am_Handle_s handle, const am_sourceID_t sourceID, const am_SourceState_e state) =0;
-	/**
-	 * this function sets the sinksoundproperty.
-	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery
-	 * value is out of range
-	 */
-	virtual am_Error_e asyncSetSinkSoundProperties(const am_Handle_s handle, const am_sinkID_t sinkID, const std::vector<am_SoundProperty_s>& listSoundProperties) =0;
-	/**
-	 * this function sets the sinksoundproperty.
-	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery
-	 * value is out of range
-	 */
-	virtual am_Error_e asyncSetSinkSoundProperty(const am_Handle_s handle, const am_sinkID_t sinkID, const am_SoundProperty_s& soundProperty) =0;
-	/**
-	 * this function sets the sourcesoundproperty.
-	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery
-	 * value is out of range
-	 */
-	virtual am_Error_e asyncSetSourceSoundProperties(const am_Handle_s handle, const am_sourceID_t sourceID, const std::vector<am_SoundProperty_s>& listSoundProperties) =0;
-	/**
-	 * this function sets the sourcesoundproperty.
-	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery
-	 * value is out of range
-	 */
-	virtual am_Error_e asyncSetSourceSoundProperty(const am_Handle_s handle, const am_sourceID_t sourceID, const am_SoundProperty_s& soundProperty) =0;
-	/**
-	 * this function triggers crossfading.
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e asyncCrossFade(const am_Handle_s handle, const am_crossfaderID_t crossfaderID, const am_HotSink_e hotSink, const am_CustomRampType_t rampType, const am_time_t time) =0;
-	/**
-	 * this function is used for early and late audio functions to set the domain
-	 * state
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e setDomainState(const am_domainID_t domainID, const am_DomainState_e domainState) =0;
-	/**
-	 * this method is used to retrieve the busname during startup of the plugin. Needs
-	 * to be implemented
-	 * @return E_OK on success, E_UNKNOWN on error
-	 */
-	virtual am_Error_e returnBusName(std::string& BusName) const =0;
-	/**
-	 * This command sets multiple source or and sink volumes within a domain at a time.
-	 * It can be used to synchronize volume setting events.
-	 * @return E_OK on success, E_UNKNOWN on error.
-	 */
-	virtual am_Error_e asyncSetVolumes(const am_Handle_s handle, const std::vector<am_Volumes_s>& listVolumes) =0;
-	/**
-	 * sets the notification configuration of a sink.
-	 * @return E_OK on success, E_UNKNOWN on error.
-	 */
-	virtual am_Error_e asyncSetSinkNotificationConfiguration(const am_Handle_s handle, const am_sinkID_t sinkID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
-	/**
-	 * sets the notification configuration of a source.
-	 * @return E_OK on success, E_UNKNOWN on error.
-	 */
-	virtual am_Error_e asyncSetSourceNotificationConfiguration(const am_Handle_s handle, const am_sourceID_t sourceID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
-
-};
-}
-#endif // !defined(EA_6B9C54C0_2366_4139_97CF_28563364DACA__INCLUDED_)
+	/**
+	 * this function is used to send out all data that has been changed in an early
+	 * state.
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual void sendChangedData(const std::vector<am_EarlyData_s>& earlyData) =0;
+	/**
+	 * this function is used to retrieve a pointer to the dBusConnectionWrapper
+	 * @return E_OK if pointer is valid, E_UKNOWN if AudioManager was compiled without
+	 * DBus Support
+	 */
+	virtual am_Error_e getDBusConnectionWrapper(CAmDbusWrapper*& dbusConnectionWrapper) const =0;
+	/**
+	 * This function returns the pointer to the socketHandler. This can be used to
+	 * integrate socket-based activites like communication with the mainloop of the
+	 * AudioManager.
+	 * returns E_OK if pointer is valid, E_UNKNOWN in case AudioManager was compiled
+	 * without socketHandler support,
+	 */
+	virtual am_Error_e getSocketHandler(CAmSocketHandler*& socketHandler) const =0;
+	/**
+	 * confirms the setRoutingReady Command
+	 */
+	virtual void  confirmRoutingReady(const uint16_t handle, const am_Error_e error) =0;
+	/**
+	 * confirms the setRoutingRundown Command
+	 */
+	virtual void  confirmRoutingRundown(const uint16_t handle, const am_Error_e error) =0;
+	/**
+	 * updates data of an converter. @return E_OK on success, E_NON_EXISTENT if the
+	 * gatewayID is not valid. 
+	 */
+	virtual am_Error_e updateConverter(const am_converterID_t converterID, const std::vector<am_CustomConnectionFormat_t>& listSourceFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkFormats, const std::vector<bool>& convertionMatrix) =0;
+	/**
+	 * updates data of an gateway. @return E_OK on success, E_NON_EXISTENT if the
+	 * gatewayID is not valid. 
+	 */
+	virtual am_Error_e updateGateway(const am_gatewayID_t gatewayID, const std::vector<am_CustomConnectionFormat_t>& listSourceFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkFormats, const std::vector<bool>& convertionMatrix) =0;
+	/**
+	 * updates data of an gateway. @return E_OK on success, E_NON_EXISTENT if the
+	 * sinkID is not valid.
+	 */
+	virtual am_Error_e updateSink(const am_sinkID_t sinkID, const am_sinkClass_t sinkClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
+	/**
+	 * updates data of an source. @return E_OK on success, E_NON_EXISTENT if the
+	 * sourceID in the struct is not valid.
+	 * Please note that only the following data out of am_Source_s have effect when
+	 * they are changed:
+	 * sourceClassID,
+	 * listSoundProperties,
+	 * listConnectionFormats,
+	 * listMainSoundProperties
+	 */
+	virtual am_Error_e updateSource(const am_sourceID_t sourceID, const am_sourceClass_t sourceClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
+	/**
+	 * acknowledges a asyncSetSinkVolumes
+	 */
+	virtual void ackSetVolumes(const am_Handle_s handle, const std::vector<am_Volumes_s>& listvolumes, const am_Error_e error) =0;
+	/**
+	 * The acknowledge of the SinkNotificationConfiguration
+	 */
+	virtual void ackSinkNotificationConfiguration(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * The acknowledge of the SourceNotificationConfiguration
+	 */
+	virtual void ackSourceNotificationConfiguration(const am_Handle_s handle, const am_Error_e error) =0;
+	/**
+	 * is called whenever a notified value needs to be send
+	 */
+	virtual void hookSinkNotificationDataChange(const am_sinkID_t sinkID, const am_NotificationPayload_s& payload) =0;
+	/**
+	 * is called whenever a notified value needs to be send
+	 */
+	virtual void hookSourceNotificationDataChange(const am_sourceID_t sourceID, const am_NotificationPayload_s& payload) =0;
+	/**
+	 * E_OK in case of success
+	 */
+	virtual am_Error_e getDomainOfSink(const am_sinkID_t sinkID, am_domainID_t& domainID) const =0;
+	/**
+	 * E_OK in case of success
+	 */
+	virtual am_Error_e getDomainOfSource(const am_sourceID_t sourceID, am_domainID_t& domainID) const =0;
+	/**
+	 * E_OK in case of success
+	 */
+	virtual am_Error_e getDomainOfCrossfader(const am_crossfaderID_t crossfader, am_domainID_t& domainID) const = 0;
+
+};
+
+/**
+ * This class implements everything from Audiomanager -> RoutingAdapter
+ * There are two rules that have to be kept in mind when implementing against this
+ * interface:\n
+ * \warning
+ * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
+ * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
+ * CALL THAT EXPECTS A RETURN VALUE.\n
+ * \details
+ * Violation these rules may lead to unexpected behavior! Nevertheless you can
+ * implement thread safe by using the deferred-call pattern described on the wiki
+ * which also helps to implement calls that are forbidden.\n
+ * For more information, please check CAmSerializer
+ */
+class IAmRoutingSend
+{
+
+public:
+	IAmRoutingSend() {
+
+	}
+
+	virtual ~IAmRoutingSend() {
+
+	}
+
+	/**
+	 * This function returns the version of the interface
+	 */
+	virtual void getInterfaceVersion(std::string& version) const =0;
+	/**
+	 * starts up the interface. In the implementations, here is the best place for
+	 * init routines.
+	 */
+	virtual am_Error_e startupInterface(IAmRoutingReceive* routingreceiveinterface) =0;
+	/**
+	 * indicates that the routing now ready to be used. Should be used as trigger to
+	 * register all sinks, sources, etc...
+	 */
+	virtual void setRoutingReady(const uint16_t handle) =0;
+	/**
+	 * indicates that the routing plugins need to be prepared to switch the power off
+	 * or be ready again.
+	 */
+	virtual void setRoutingRundown(const uint16_t handle) =0;
+	/**
+	 * aborts an asynchronous action.
+	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if handle was not
+	 * found
+	 */
+	virtual am_Error_e asyncAbort(const am_Handle_s handle) =0;
+	/**
+	 * connects a source to a sink
+	 * @return E_OK on success, E_UNKNOWN on error, E_WRONG_FORMAT in case
+	 * am_ConnectionFormat_e does not match
+	 */
+	virtual am_Error_e asyncConnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_sourceID_t sourceID, const am_sinkID_t sinkID, const am_CustomConnectionFormat_t connectionFormat) =0;
+	/**
+	 * disconnect a connection with given connectionID
+	 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if connection was
+	 * not found
+	 */
+	virtual am_Error_e asyncDisconnect(const am_Handle_s handle, const am_connectionID_t connectionID) =0;
+	/**
+	 * this method is used to set the volume of a sink. This function is used to drive
+	 * ramps, to mute or unmute or directly set the value. The difference is made
+	 * through the ramptype.
+	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE if new volume is
+	 * out of range
+	 */
+	virtual am_Error_e asyncSetSinkVolume(const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume, const am_CustomRampType_t ramp, const am_time_t time) =0;
+	/**
+	 * sets the volume of a source. This method is used to set the volume of a sink.
+	 * This function is used to drive ramps, to mute or unmute or directly set the
+	 * value. The difference is made through the ramptype.
+	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
+	 * range.
+	 * triggers the acknowledge ackSourceVolumeChange
+	 */
+	virtual am_Error_e asyncSetSourceVolume(const am_Handle_s handle, const am_sourceID_t sourceID, const am_volume_t volume, const am_CustomRampType_t ramp, const am_time_t time) =0;
+	/**
+	 * This function is used to set the source state of a particular source.
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e asyncSetSourceState(const am_Handle_s handle, const am_sourceID_t sourceID, const am_SourceState_e state) =0;
+	/**
+	 * this function sets the sinksoundproperty.
+	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery
+	 * value is out of range
+	 */
+	virtual am_Error_e asyncSetSinkSoundProperties(const am_Handle_s handle, const am_sinkID_t sinkID, const std::vector<am_SoundProperty_s>& listSoundProperties) =0;
+	/**
+	 * this function sets the sinksoundproperty.
+	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery
+	 * value is out of range
+	 */
+	virtual am_Error_e asyncSetSinkSoundProperty(const am_Handle_s handle, const am_sinkID_t sinkID, const am_SoundProperty_s& soundProperty) =0;
+	/**
+	 * this function sets the sourcesoundproperty.
+	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery
+	 * value is out of range
+	 */
+	virtual am_Error_e asyncSetSourceSoundProperties(const am_Handle_s handle, const am_sourceID_t sourceID, const std::vector<am_SoundProperty_s>& listSoundProperties) =0;
+	/**
+	 * this function sets the sourcesoundproperty.
+	 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery
+	 * value is out of range
+	 */
+	virtual am_Error_e asyncSetSourceSoundProperty(const am_Handle_s handle, const am_sourceID_t sourceID, const am_SoundProperty_s& soundProperty) =0;
+	/**
+	 * this function triggers crossfading.
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e asyncCrossFade(const am_Handle_s handle, const am_crossfaderID_t crossfaderID, const am_HotSink_e hotSink, const am_CustomRampType_t rampType, const am_time_t time) =0;
+	/**
+	 * this function is used for early and late audio functions to set the domain
+	 * state
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e setDomainState(const am_domainID_t domainID, const am_DomainState_e domainState) =0;
+	/**
+	 * this method is used to retrieve the busname during startup of the plugin. Needs
+	 * to be implemented
+	 * @return E_OK on success, E_UNKNOWN on error
+	 */
+	virtual am_Error_e returnBusName(std::string& BusName) const =0;
+	/**
+	 * This command sets multiple source or and sink volumes within a domain at a time.
+	 * It can be used to synchronize volume setting events.
+	 * @return E_OK on success, E_UNKNOWN on error.
+	 */
+	virtual am_Error_e asyncSetVolumes(const am_Handle_s handle, const std::vector<am_Volumes_s>& listVolumes) =0;
+	/**
+	 * sets the notification configuration of a sink.
+	 * @return E_OK on success, E_UNKNOWN on error.
+	 */
+	virtual am_Error_e asyncSetSinkNotificationConfiguration(const am_Handle_s handle, const am_sinkID_t sinkID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
+	/**
+	 * sets the notification configuration of a source.
+	 * @return E_OK on success, E_UNKNOWN on error.
+	 */
+	virtual am_Error_e asyncSetSourceNotificationConfiguration(const am_Handle_s handle, const am_sourceID_t sourceID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
+
+};
+}
+#endif // !defined(EA_6B9C54C0_2366_4139_97CF_28563364DACA__INCLUDED_)
-- 
1.9.3

